\section{Closure Properties of Regular Languages}
\label{ClosurePropertiesOfRegularLanguages}

\index{regular languages!closure properties|(}%

In this section, we show how to convert regular expressions to finite
automata, as well as how to convert finite automata to regular
expressions.  As a result, we will be able to conclude that the
following statements about a language $L$ are equivalent:
\begin{itemize}
\item $L$ is regular;

\item $L$ is generated by a regular expression;

\item $L$ is accepted by a finite automaton;

\item $L$ is accepted by an EFA;

\item $L$ is accepted by an NFA; and

\item $L$ is accepted by a DFA.
\end{itemize}

Also, we will introduce:
\begin{itemize}
\item operations on FAs corresponding to union, concatenation and
  closure;

\item an operation on EFAs corresponding to intersection; and

\item an operation on DFAs corresponding to set difference.
\end{itemize}
As a result, we will have that the set $\RegLan$ of regular languages
is closed under union, concatenation, closure, intersection and set
difference.  I.e., we will have that, if $L,L_1,L_2\in\RegLan$, then
$L_1\cup L_2$, $L_1L_2$, $L^*$, $L_1\cap L_2$ and $L_1-L_2$ are in
$\RegLan$.

We will also show several additional closure properties of regular
languages, in addition to giving the corresponding operations on regular
expressions and automata.

\subsection{Converting Regular Expressions to FAs}

\index{regular expression!converting to FA}%
\index{finite automaton!converting from regular expression}%

In order to give an algorithm for converting regular expressions to
finite automata, we must first define several constants and operations
on FAs.

\index{finite automaton!emptyStr@$\emptyStr$}%
We write $\emptyStr$ for the \emph{canonical finite
automaton for} $\%$,
\begin{center}
\input{chap-3.12-fig1.eepic}
\end{center}
\index{finite automaton!emptySet@$\emptySet$}%
And we write $\emptySet$ for \emph{canonical finite automaton for} $\emptyset$,
\begin{center}
\input{chap-3.12-fig2.eepic}
\end{center}
Thus, we have that $L(\emptyStr)=\{\%\}$ and $L(\emptySet)=\emptyset$.
Furthermore both $\emptyStr$ and $\emptySet$ are DFAs, so that they
are also NFAs and EFAs.  Thus, we also refer to $\emptyStr$ as the
\emph{canonical DFA/NFA/EFA/FA for} $\%$, and $\emptySet$ as the
\emph{canonical DFA/NFA/EFA/FA for} $\emptyset$.

\index{finite automaton!strToFA@$\strToFA$}%
Next, we define a function $\strToFA\in\Str\fun\FA$ by:
$\strToFA\,x$ is the \emph{canonical finite automaton for} $x$,
\begin{center}
\input{chap-3.12-fig10.eepic}
\end{center}
Thus, for all $x\in\Str$, $L(\strToFA\,x)=\{x\}$.
\index{nondeterministic finite automaton!symToNFA@$\symToNFA$}%
It is also convenient to define a function $\symToNFA\in\Sym\fun\NFA$
by: $\symToNFA\,a=\strToFA\,a$.  Then, for all $a\in\Sym$,
$L(\symToNFA\,a)=\{a\}$.  Of course, $\symToNFA$ is also an element of
$\Sym\fun\EFA$ and $\Sym\fun\FA$, and we say that $\symToNFA\,a$ is
the \emph{canonical NFA/EFA/FA for} $a$.

\index{language!union}%
\index{finite automaton!union}%
\index{finite automaton!union@$\union$}%
Next, we define a function/algorithm $\union\in\FA\times\FA\fun\FA$
such that $L(\union(M_1,M_2))=L(M_1)\cup L(M_2)$, for all
$M_1,M_2\in\FA$.  If $M_1,M_2\in\FA$, then $\union(M_1,M_2)$,
\emph{the union of} $M_1$ \emph{and} $M_2$, is the FA $N$ such that:
\begin{itemize}
\item $Q_N= \{\Asf\}\cup\setof{\langle\onesf,q\rangle}{q\in
    Q_{M_1}}\cup \setof{\langle\twosf,q\rangle}{q\in Q_{M_2}}$;

\item $s_N=\Asf$;

\item $A_N=\setof{\langle\onesf,q\rangle}{q\in A_{M_1}}\cup
  \setof{\langle\twosf,q\rangle}{q\in A_{M_2}}$; and

\item $T_N={}$

\begin{align*}
  &\quad
  \,\{\Asf,\%\fun \langle\onesf,s_{M_1}\rangle\} \\
  &\cup \{\Asf,\%\fun\langle\twosf,s_{M_2}\rangle\} \\
  &\cup \setof{\langle\onesf,q\rangle,a\fun\langle\onesf,r\rangle}{q,
    a\fun r\in T_{M_1}}
  \\
  &\cup \setof{\langle\twosf,q\rangle,a\fun\langle\twosf,r\rangle}{q,
    a\fun r \in T_{M_2}}.
\end{align*}
\end{itemize}

For example, if $M_1$ and $M_2$ are the FAs
\begin{center}
\input{chap-3.12-fig3.eepic}
\input{chap-3.12-fig4.eepic}
\end{center}
then $\union(M_1,M_2)$ is the FA
\begin{center}
\input{chap-3.12-fig5.eepic}
\end{center}

\begin{proposition}
For all $M_1,M_2\in\FA$:
\begin{itemize}
\item $L(\union(M_1,M_2))=L(M_1)\cup L(M_2)$; and

\item $\alphabet(\union(M_1,M_2))=\alphabet\,M_1\cup\alphabet\,M_2$.
\end{itemize}
\end{proposition}

\begin{proposition}
For all $M_1,M_2\in\EFA$, $\union(M_1,M_2)\in\EFA$.
\end{proposition}

\index{language!concatenation}%
\index{finite automaton!concatenation}%
\index{finite automaton!concat@$\concat$}%
Next, we define a function/algorithm $\concat\in\FA\times\FA\fun\FA$
such that $L(\concat(M_1,M_2))=L(M_1)L(M_2)$, for all
$M_1,M_2\in\FA$.  If $M_1,M_2\in\FA$, then $\concat(M_1,M_2)$, \emph{the
concatentation of} $M_1$ \emph{and} $M_2$, is the
FA $N$ such that:
\begin{itemize}
\item $Q_N=\setof{\langle\onesf,q\rangle}{q\in Q_{M_1}}\cup
\setof{\langle\twosf,q\rangle}{q\in Q_{M_2}}$;

\item $s_N=\langle\onesf,s_{M_1}\rangle$;

\item $A_N=\setof{\langle\twosf,q\rangle}{q\in
A_{M_2}}$; and

\item $T_N={}$
  \begin{align*}
    &\quad\,
    \setof{\langle\onesf,q\rangle,\%\fun\langle\twosf,s_{M_2}\rangle}{q\in
      A_{M_1}}
    \\
    &\cup
    \setof{\langle\onesf,q\rangle,a\fun\langle\onesf,r\rangle}{q,
      a\fun r\in T_{M_1}}
    \\
    &\cup
    \setof{\langle\twosf,q\rangle,a\fun\langle\twosf,r\rangle}{q,
      a\fun r\in T_{M_2}}.
  \end{align*}
\end{itemize}

For example, if $M_1$ and $M_2$ are the FAs
\begin{center}
\input{chap-3.12-fig11.eepic}
\input{chap-3.12-fig12.eepic}
\end{center}
then $\concat(M_1,M_2)$ is the FA
\begin{center}
\input{chap-3.12-fig6.eepic}
\end{center}

\begin{proposition}
For all $M_1,M_2\in\FA$:
\begin{itemize}
\item $L(\concat(M_1,M_2))=L(M_1)L(M_2)$; and

\item $\alphabet(\concat(M_1,M_2))=\alphabet\,M_1\cup\alphabet\,M_2$.
\end{itemize}
\end{proposition}

\begin{proposition}
For all $M_1,M_2\in\EFA$, $\concat(M_1,M_2)\in\EFA$.
\end{proposition}

\index{language!closure}%
\index{finite automaton!closure}%
\index{finite automaton!closure@$\closure$}%
Next, we define a function/algorithm $\closure\in\FA\fun\FA$ such that
$L(\closure\,M)=L(M)^*$, for all $M\in\FA$.  If $M\in\FA$, then
$\closure\,M$, \emph{the closure of} $M$, is the FA $N$ such that:
\begin{itemize}
\item $Q_N=\{\Asf\}\cup\setof{\langle q\rangle}{q\in Q_M}$;

\item $s_N=\Asf$;

\item $A_N=\{\Asf\}$; and

\item $T_N={}$
  \begin{align*}
    &\quad\, \{\Asf,\%\fun\langle s_M\rangle\} \\
    &\cup \setof{\langle q\rangle,\%\fun\Asf}{q\in A_M} \\
    &\cup \setof{\langle q\rangle,a\fun\langle r\rangle}{q,a\fun r\in
      T_M}.
  \end{align*}
\end{itemize}

For example, if $M$ is the FA
\begin{center}
\input{chap-3.12-fig7.eepic}
\end{center}
then $\closure\,M$ is the FA
\begin{center}
\input{chap-3.12-fig8.eepic}
\end{center}

\begin{proposition}
For all $M\in\FA$,
\begin{itemize}
\item $L(\closure\,M)=L(M)^*$; and

\item $\alphabet(\closure\,M)=\alphabet\,M$.
\end{itemize}
\end{proposition}

\begin{proposition}
For all $M\in\EFA$, $\closure\,M\in\EFA$.
\end{proposition}

\index{regular expression!regToFA@$\regToFA$}%
\index{finite automaton!regToFA@$\regToFA$}%
We define a function/algorithm $\regToFA\in\Reg\fun\FA$ by well-founded
recursion on the height of regular expressions, as follows.
The goal is for $L(\regToFA\,\alpha)$ to be equal to $L(\alpha)$, for
all regular expressions $\alpha$.
\begin{itemize}
\item $\regToFA\,\% = \emptyStr$;

\item $\regToFA\,\$ = \emptySet$;

\item for all $\alpha\in\Reg$, $\regToFA(\alpha^*) =
  \closure(\regToFA\,\alpha)$;

\item for all $\alpha,\beta\in\Reg$, $\regToFA(\alpha+\beta) =
  \union(\regToFA\,\alpha,\regToFA\,\beta)$;

\item for all $n\in\nats-\{0\}$ and $a_1,\,\ldots,a_n\in\Sym$,
  $\regToFA(a_1\cdots a_n)=\strToFA(a_1\cdots a_n)$;

\item for all $n\in\nats-\{0\}$, $a_1,\,\ldots,a_n\in\Sym$ and
  $\alpha\in\Reg$, if $\alpha$ doesn't consist of a single symbol, and
  doesn't have the form $b\,\beta$ for some $b\in\Sym$ and
  $\beta\in\Reg$, then $\regToFA(a_1\,\cdots\,a_n\,\alpha)=
  \concat(\strToFA(a_1\cdots a_n),\regToFA\,\alpha)$; and

\item for all $\alpha,\beta\in\Reg$, if $\alpha$ doesn't consist of a
  single symbol, then $\regToFA(\alpha\beta)=
  \concat(\regToFA\,\alpha,\regToFA\,\beta)$.
\end{itemize}

For example, $\regToFA(\mathsf{0101^*})=
\concat(\strToFA(010),\regToFA(1^*))$.

\begin{theorem}
For all $\alpha\in\Reg$:
\begin{itemize}
\item $L(\regToFA\,\alpha)=L(\alpha)$; and

\item $\alphabet(\regToFA\,\alpha)=\alphabet\,\alpha$.
\end{itemize}
\end{theorem}

\begin{proof}
Because of the form of recursion used, the proof uses well-founded
induction on the height of $\alpha$.
\end{proof}

For example, $\regToFA(\mathsf{0^*11+001^*})$ is isomorphic to
the FA
\begin{center}
\input{chap-3.12-fig9.eepic}
\end{center}

The Forlan module \texttt{FA} includes these constants and functions
for building finite automata and converting regular expressions to
finite automata:
\begin{verbatim}
val emptyStr : fa
val emptySet : fa
val fromStr  : str -> fa
val fromSym  : sym -> fa
val union    : fa * fa -> fa
val concat   : fa * fa -> fa
val closure  : fa -> fa
val fromReg  : reg -> fa
\end{verbatim}
\index{FA@\texttt{FA}!emptyStr@\texttt{emptyStr}}%
\index{FA@\texttt{FA}!emptySet@\texttt{emptySet}}%
\index{FA@\texttt{FA}!fromStr@\texttt{fromStr}}%
\index{FA@\texttt{FA}!fromSym@\texttt{fromSym}}%
\index{FA@\texttt{FA}!union@\texttt{union}}%
\index{FA@\texttt{FA}!concat@\texttt{concat}}%
\index{FA@\texttt{FA}!closure@\texttt{closure}}%
\index{FA@\texttt{FA}!fromReg@\texttt{fromReg}}%
\texttt{emptyStr} and \texttt{emptySet} correspond to $\emptyStr$ and
$\emptySet$, respectively.
The functions \texttt{fromStr} and \texttt{fromSym} correspond to
$\strToFA$ and $\symToNFA$, and are also available in the top-level
environment with the names
\begin{verbatim}
val strToFA : str -> fa
val symToFA : sym -> fa
\end{verbatim}
\index{finite automaton!strToFA@\texttt{strToFA}}%
\index{finite automaton!symToFA@\texttt{symToFA}}%
\texttt{union} and \texttt{concat} and \texttt{closure} correspond to
$\union$, $\concat$ and $\closure$, respectively.
The function \texttt{fromReg} corresponds to $\regToFA$ and is
available in the top-level environment with that name:
\begin{verbatim}
val regToFA : reg -> fa
\end{verbatim}
\index{finite automaton!regToFA@\texttt{regToFA}}%
The constants \texttt{emptyStr} and \texttt{emptySet} are inherited by
the modules \texttt{DFA}, \texttt{NFA} and \texttt{EFA}.
\index{DFA@\texttt{DFA}!emptyStr@\texttt{emptyStr}}%
\index{DFA@\texttt{DFA}!emptySet@\texttt{emptySet}}%
\index{NFA@\texttt{NFA}!emptyStr@\texttt{emptyStr}}%
\index{NFA@\texttt{NFA}!emptySet@\texttt{emptySet}}%
\index{EFA@\texttt{EFA}!emptyStr@\texttt{emptyStr}}%
\index{EFA@\texttt{EFA}!emptySet@\texttt{emptySet}}%
The function \texttt{fromSym} is inherited by
the modules \texttt{NFA} and \texttt{EFA}, and is available in
\index{NFA@\texttt{NFA}!fromSym@\texttt{fromSym}}%
\index{EFA@\texttt{EFA}!fromSym@\texttt{fromSym}}%
the top-level environment with the names
\begin{verbatim}
val symToNFA : sym -> nfa
val symToEFA : sym -> efa
\end{verbatim}
\index{nondeterministic finite automaton!symToNFA@\texttt{symToNFA}}%
\index{empty string finite automaton!symToEFA@\texttt{symToEFA}}%
The functions \texttt{union}, \texttt{concat} and \texttt{closure} are
inherited by the module \texttt{EFA}.
\index{EFA@\texttt{EFA}!union@\texttt{union}}%
\index{EFA@\texttt{EFA}!concat@\texttt{concat}}%
\index{EFA@\texttt{EFA}!closure@\texttt{closure}}%

Here is how the regular expression $\mathsf{0^*11+001^*}$ can
be converted to an FA in Forlan:
\input{chap-3.12-forlan1}
Thus \texttt{fa'} is the finite automaton
\begin{center}
\input{chap-3.12-fig9.eepic}
\end{center}

Putting together our algorithm for converting regular expressions to finite
automata with our algorithm for checking whether strings are accepted by
finite automata, we are now able to check whether strings are
generated by regular expressions:
\input{chap-3.12-forlan1a}

\subsection{Converting FAs to Regular Expressions}

\index{regular expression!converting from FA}%
\index{finite automaton!converting to regular expression}%

Our algorithm for converting FAs to regular expressions makes
use of a more general kind of finite automata that we call
regular expression finite automata.

\index{regular expression finite automaton}%
\index{finite automaton!regular expression}%
\index{RFA}%
A \emph{regular expression finite automaton} (RFA) $M$ consists of:
\begin{itemize}
\item a finite set $Q_M$ of symbols;

\item an element $s_M$ of $Q_M$;

\item a subset $A_M$ of $Q_M$; and

\item a finite subset $T_M$ of
$\setof{(q,{\alpha},r)}{q,r\in Q_M\eqtxt{and}
{\alpha}\in{\Reg}}$ such that,
for all $q,r\in Q_M$, there is at most one $\alpha\in\Reg$
such that $(q,\alpha,r)\in T_M$.
\end{itemize}
As usual $Q_M$ consists of $M$'s \emph{states}, $s_M$ is $M$'s
\emph{start state}, $A_M$ consists of $M$'s \emph{accepting states},
and $T_M$ consists of $M$'s \emph{transitions}.  We often write
a transition $(q,\alpha,r)$ as
\begin{gather*}
q\tranarr{\alpha}r
\end{gather*}
or $q,\alpha\fun r$.
We write $\RFA$ for the set of all RFAs, which is a countably infinite
set.  RFAs are drawn analogously to FAs, and the Forlan syntax for
RFAs is analogous to that of FAs.

For example, the RFA $M$ whose states are $\Asf$ and $\Bsf$, start
state is $\Asf$, only accepting state is $\Bsf$, and
transitions are $(\Asf,\twosf, \Asf)$, $(\Asf,\zerosf\zerosf^*,\Bsf)$,
$(\Bsf,\threesf,\Bsf)$ and $(\Bsf,\onesf\onesf^*,\Asf)$ can
be drawn as
\begin{center}
\input{chap-3.12-fig13.eepic}  
\end{center}
and expressed in Forlan as
\begin{verbatim}
{states} A, B {start state} A {accepting states} B
{transitions} A, 2 -> A; A, 00* -> B; B, 3 -> B; B, 11* -> A
\end{verbatim}

\index{regular expression finite automaton!alphabet}%
\index{regular expression finite automaton!alphabet@$\alphabet$}
We define a function $\alphabet\in\RFA\fun\Alp$ by: for all
$M\in\RFA$, $\alphabet\,M$ is $\setof{a\in\Sym}{\eqtxt{there
    are}q,\alpha,r\eqtxt{such that} q,\alpha\fun r\in
  T_M\eqtxt{and}a\in\alphabet\,\alpha}$.  I.e., $\alphabet\,M$ is the
union of the alphabets of all of the regular expressions appearing in
$M$'s transitions.  We say that $\alphabet\,M$ is \emph{the alphabet
  of} $M$.  For example, the alphabet of our example FA $M$ is
$\{\mathsf{0,1,2}\}$.

The Forlan module \texttt{RFA} defines an abstract type \texttt{rfa}
\index{RFA@\texttt{RFA}}%
\index{RFA@\texttt{RFA}!rfa@\texttt{rfa}}%
(in the top-level environment) of regular expression finite automata,
as well as some functions for processing RFAs including:
\begin{verbatim}
val input          : string -> rfa
val output         : string * rfa -> unit 
val alphabet       : rfa -> sym set
val numStates      : rfa -> int
val numTransitions : rfa -> int
val equal          : rfa * rfa -> bool
\end{verbatim}
\index{RFA@\texttt{RFA}!input@\texttt{input}}%
\index{RFA@\texttt{RFA}!output@\texttt{output}}%
\index{RFA@\texttt{RFA}!alphabet@\texttt{alphabet}}%
\index{RFA@\texttt{RFA}!numStates@\texttt{numStates}}%
\index{RFA@\texttt{RFA}!numTransitions@\texttt{numTransitions}}%
\index{RFA@\texttt{RFA}!equal@\texttt{equal}}%
\index{JForlan}
JForlan can be used to view and edit regular expression finite
automata.  It can be invoked directly, or run via Forlan.  See the
Forlan website for more information.

The isomorphism relation between RFAs is defined in an analogous way
to this relation for FAs.  And the functions $\renameStates$
and $\renameStatesCanonically$ are also defined analogously, and
have analogous properties. The \texttt{RFA} module has the functions
\begin{verbatim}
val renameStates            : rfa * sym_rel -> rfa
val renameStatesCanonically : rfa -> rfa
\end{verbatim}
\index{RFA@\texttt{RFA}!renameStates@\texttt{renameStates}}%
\index{RFA@\texttt{RFA}!renameStatesCanonically@\texttt{renameStatesCanonically}}%

\index{regular expression finite automaton!labeled path}%
A labeled path
\begin{gather*}
q_1\lparr{x_1}q_2\lparr{x_2}\cdots\,q_n\lparr{x_n}q_{n+1} ,
\end{gather*}
is \emph{valid for} an RFA $M$ iff, for all $i\in[1:n]$,
\begin{gather*}
x_i\in L(\alpha),\eqtxt{for some}\alpha\in\Reg\eqtxt{such that}
q_i,\alpha\fun q_{i+1} ,
\end{gather*}
and $q_{n+1}\in Q_M$.
For example, the labeled path
\begin{gather*}
\Asf\lparr{\mathsf{000}}\Bsf\lparr{3}\Bsf
\end{gather*}
is valid for our example FA $M$, because
\begin{itemize}
\item $\mathsf{000}\in L(\mathsf{00^*})$ and
  $\Asf,\mathsf{00^*}\fun\Bsf\in T$, and

\item $\mathsf{3}\in L(\mathsf{3})$ and $\Bsf,\mathsf{3}\fun\Bsf\in
  T$.
\end{itemize}

The \texttt{RFA} module contains the functions
\begin{verbatim}
val checkLP : (str * reg -> bool) * rfa -> lp -> unit
val validLP : (str * reg -> bool) * rfa -> lp -> bool
\end{verbatim}
\index{RFA@\texttt{RFA}!checkLP@\texttt{checkLP}}%
\index{RFA@\texttt{RFA}!validLP@\texttt{validLP}}%
which are analogous to the identically named functions provided by
\texttt{FA}, except that they take a first argument whose job is
to test whether a string is generated by a regular expression.
For example, we can proceed as follows:
\input{chap-3.12-forlan2}

\index{regular expression finite automaton!accepted by}%
A string $w$ is \emph{accepted by} an RFA $M$ iff
there is a labeled path $\lp$ such that
\begin{itemize}
\item the label of $\lp$ is $w$;

\item $\lp$ is valid for $M$;

\item the start state of $\lp$ is the start state of $M$; and

\item the end state of $\lp$ is an accepting state of $M$.
\end{itemize}
We have that, if $w$ is accepted by $M$, then
$\alphabet\,w\sub\alphabet\,M$.
\index{regular expression finite automaton!meaning}%
\index{regular expression finite automaton!language accepted by}%
\index{L(@$L(\cdot)$}%
\index{regular expression finite automaton!L(@$L(\cdot)$}%}%
The \emph{language accepted by} an RFA $M$ ($L(M)$) is
\begin{gather*}
\setof{w\in\Str}{w\eqtxt{is accepted by}M}.
\end{gather*}

Consider our example RFA $M$:
\begin{center}
\input{chap-3.12-fig13.eepic}
\end{center}
We have that $\mathsf{20}$ and $\mathsf{0000111103}$ are
accepted by $M$, but that $\mathsf{23}$ and $\mathsf{122}$ are
not accepted by $M$.

We define a function $\combineTrans$ that takes in a pair $(\Simp, U)$
such that
\begin{itemize}
\item $\Simp\in\Reg\fun\Reg$ and

\item $U$ is a finite subset of
  $\setof{p,\alpha\fun q}{p,q\in\Sym\eqtxt{and}\alpha\in\Reg}$,
\end{itemize}
and returns a finite subset $V$ of $\setof{p,\alpha\fun
  q}{p,q\in\Sym\eqtxt{and}\alpha\in\Reg}$ with the property that, for
all $p,q\in\Sym$, there is at most one $\beta$ such that $p,\beta\fun
q\in V$.
Given such a pair $(\Simp, U)$, $\combineTrans$ returns the set of all
transitions $p,\alpha\fun q$ such that $\setof{\beta}{p,\beta\fun q\in U}$
is nonempty, and $\alpha = \Simp(\beta_1+\cdots+\beta_n)$,
where $\beta_1,\ldots,\beta_n$ are all of the elements of this set,
listed in increasing order and without repetition.

Now, we define a function/algorithm
\index{regular expression!faToRFA@$\faToRFA$}%
\index{regular expression finite automata!faToRFA@$\faToRFA$}%
\begin{gather*}
\faToRFA\in(\Reg\fun\Reg)\fun\FA\fun\RFA .  
\end{gather*}
$\faToRFA$ takes in $\Simp\in\Reg\fun\Reg$, and returns a
function that takes in $M\in\FA$, and returns the RFA
$N$ such that:
\begin{itemize}
\item $Q_N = Q_M$;

\item $s_N = s_M$;

\item $A_N = A_M$; and

\item $T_N = \combineTrans(\Simp,
  \setof{p, \strToReg\,x\fun q}{p,x\fun q\in T_M})$.
\end{itemize}

For example, if the FA $M$ is
\begin{center}
  \input{chap-3.12-fig25.eepic}
\end{center}
and $\Simp$ is $\locallySimplify\,\obviousSubset$,
then $\faToRFA\,\Simp\,M$ is the RFA
\begin{center}
  \input{chap-3.12-fig26.eepic}
\end{center}

\begin{proposition}
Suppose $\Simp\in\Reg\fun\Reg$ and $M\in\FA$.  If, for all
$\alpha\in\Reg$, $L(\Simp\,\alpha)=L(\alpha)$ and
$\alphabet(\Simp\,\alpha)\sub\alphabet\,\alpha$, then
\begin{enumerate}[\quad(1)]
\item $L(\faToRFA\,\Simp\,M) = L(M)$, and

\item $\alphabet(\faToRFA\,\Simp\,M) = \alphabet\,M$.
\end{enumerate}
\end{proposition}

The \texttt{RFA} module has a function
\begin{verbatim}
val fromFA : (reg -> reg) -> fa -> rfa
\end{verbatim}
\index{RFA@\texttt{RFA}!fromFA@\texttt{fromFA}}%
that corresponds to $\faToRFA$.
Here is how our conversion example can be carried out in Forlan:
\input{chap-3.12-forlan2a}

We say that an RFA $M$ is \emph{standard} iff
\begin{itemize}
\item $M$'s start state is not an accepting state, and there are no
  transitions \emph{into} $M$'s start state (even from $s_M$ to
  itself); and

\item $M$ has a single accepting state, and there are no transitions
  \emph{from} that state (even from the accepting state to itself).
\end{itemize}

\index{regular expression finite automaton!standard}%
\begin{proposition}
Suppose $M$ is a standard RFA with only two states,
and that $q$ is $M's$ accepting state.
\begin{enumerate}[\quad(1)]
\item For all $\alpha\in\Reg$, if $s_M,\alpha\fun q$, then
  $L(M) = L(\alpha)$.

\item If there is no $\alpha\in\Reg$ such that $s_M,\alpha\fun q$,
  then $L(M) = \emptyset$.
\end{enumerate}
\end{proposition}

\index{regular expression finite automaton!standardize@$\standardize$}%
We define a function $\standardize\in\RFA\fun\RFA$ that standardizes
an RFA, as follows.  Given an argument $M$, it returns the RFA $N$
such that:
\begin{itemize}
\item $Q_N = \setof{\langle q\rangle}{q\in Q_M}\cup\{\Asf,\Bsf\}$;

\item $s_N = \Asf$;

\item $A_N = \{\Bsf\}$; and

\item $T_N$
  \begin{align*}
    &= \{\Asf,\%\fun\langle s_M\rangle\} \\
    &\cup \;\setof{\langle q\rangle,\%\fun\Bsf}{q\in A_M} \\
    &\cup \;\setof{\langle q\rangle,\alpha\fun\langle r\rangle}%
            {q,\alpha\fun r\in T_M}.
  \end{align*}
\end{itemize}

For example, if $M$ is the RFA
\begin{center}
  \input{chap-3.12-fig26.eepic}
\end{center}
then $\standardize\,M$ is the RFA
\begin{center}
  \input{chap-3.12-fig32.eepic}
\end{center}

\begin{proposition}
Suppose $M$ is an RFA.  Then:
\begin{itemize}
\item $\standardize\,M$ is standard;

\item $L(\standardize\,M) = L(M)$; and

\item $\alphabet(\standardize\,M) = \alphabet\,M$.
\end{itemize}
\end{proposition}

The \texttt{RFA} module has functions
\begin{verbatim}
val standard    : rfa -> bool
val standardize : rfa -> rfa
\end{verbatim}
\index{RFA@\texttt{RFA}!standard@\texttt{standard}}%
\index{RFA@\texttt{RFA}!standardize@\texttt{standardize}}%
The function \texttt{standard} tests whether an RFA is standard,
and the function \texttt{standardize} corresponds to
$\standardize$.

Here is how the above example can be carried out in Forlan:
\input{chap-3.12-forlan2b}

\index{regular expression finite automata!eliminateState@$\eliminateState$}%
Next, we define a function $\eliminateState$ that takes in a function
$\Simp\in\Reg\fun\Reg$, and returns a function that takes in a pair
$(M, q)$, where $M$ is an RFA and $q\in Q_M-(\{s_M\}\cup A_M)$, and
returns an RFA.  When called with such a $\Simp$ and $(M,q)$,
$\eliminateState$ returns the RFA $N$ such that:
\begin{itemize}
\item $Q_N = Q_M - \{q\}$;

\item $s_N = s_M$;

\item $A_N = A_M$; and

\item $T_N = \combineTrans(\Simp, U\cup V)$, where
  \begin{itemize}
  \item $U = \setof{p,\alpha\fun r\in T_M}{p\neq q\eqtxt{and}r\neq
      q}$,

  \item $V = \setof{p,\Simp(\alpha\beta^*\gamma)\fun r}{p\neq q, r\neq
      q, p,\alpha\fun q\in T_M \eqtxt{and} q,\gamma\fun r\in T_M}$, and

  \item $\beta$ is the unique $\alpha\in\Reg$ such that
    $q,\alpha\fun q\in T_M$, if such an $\alpha$ exists, and is $\%$,
    otherwise.
  \end{itemize}
\end{itemize}

Suppose $\Simp$ is $\locallySimplify\,\obviousSubset$ and $M$ is the FA
\begin{center}
\input{chap-3.12-fig27.eepic}
\end{center}
Then $\eliminateState\,\Simp\,(M, \Bsf)$ is
\begin{center}
\input{chap-3.12-fig28.eepic}
\end{center}
And, we can eliminate $\Csf$ from this RFA, yielding
\begin{center}
\input{chap-3.12-fig31.eepic}
\end{center}
Alternatively, we could eliminate $\Csf$ from
\begin{center}
\input{chap-3.12-fig27.eepic}
\end{center}
yielding
\begin{center}
\input{chap-3.12-fig29.eepic}
\end{center}
And could then eliminate $\Bsf$ from this RFA, yielding
\begin{center}
\input{chap-3.12-fig31.eepic}
\end{center}
($\Simp(\mathsf{0(13^*2)^*(13^*4)}) = \mathsf{01(3+21)^*4}$.)

If we had an efficient regular expression simplifier that produced
optimal results, then the order in which we eliminated states would be
irrelevant.  But using our existing simplifiers, it turns out that
eliminating states in some orders produces much better results than
doing so in other orders.  Instead of eliminating first $\Csf$ and then
$\Bsf$, we could have renamed $M$'s states using the bijection
\begin{gather*}
\{\mathsf{(A, A), (B, C), (C, B), (D, D)}\}  
\end{gather*}
and then have eliminted states in ascending order, according
to our usual ordering on symbols: first $\Bsf$ and then $\Csf$.
This is the approach we'll use when looking for alternative answers.

\begin{proposition}
Suppose $\Simp\in\Reg\fun\Reg$, $M$ is an RFA and $q\in
Q_M-(\{s_M\}\cup A_M)$.  Then:
\begin{enumerate}[\quad(1)]
\item $\eliminateState\,\Simp\,(M,q)$ has one less state than $M$.

\item If $M$ is standard, then $\eliminateState\,\Simp\,(M,q)$ is standard.

\item If, for all $\alpha\in\Reg$, $L(\Simp\,\alpha) = L(\alpha)$,
  then
  \begin{displaymath}
    L(\eliminateState\,\Simp\,(M,q)) = L(M) .  
  \end{displaymath}

\item If, for all $\alpha\in\Reg$, $\alphabet(\Simp\,\alpha)\sub
  \alphabet\,\alpha$, then
  \begin{displaymath}
    \alphabet(\eliminateState\,\Simp\,(M,q)) \sub \alphabet\,M .
  \end{displaymath}
\end{enumerate}
\end{proposition}

The \texttt{RFA} module has a function
\begin{verbatim}
val eliminateState : (reg -> reg) -> rfa * sym -> rfa
\end{verbatim}
\index{RFA@\texttt{RFA}!eliminateState@\texttt{eliminateState}}%
that corresponds to $\eliminateState$.
Here is how our state-elimination examples can be carried out in Forlan:
\input{chap-3.12-forlan3}
And \texttt{eliminateState} stops us from eliminating a start state or
an accepting state:
\input{chap-3.12-forlan3a}

\index{regular expression finite automaton!rfaToReg@$\rfaToReg$}%
Now, we use $\eliminateState$ to define a function/algorithm
\begin{displaymath}
  \rfaToReg \in (\Reg\fun\Reg) \fun \RFA \fun \Reg .
\end{displaymath}
It takes elements $\Simp\in\Reg\fun\Reg$ and $M\in\RFA$, and
returns
\begin{displaymath}
  f(\standardize\,M) ,
\end{displaymath}
where $f$ is the function from standard RFAs to regular expressions
that is defined by well-founded recursion on the number of states of
its input, $M$, as follows:
\begin{itemize}
\item If $M$ has only two states,  then $f$ returns the
  label of the transition from $s_M$ to $M$'s accepting state, if such
  a transition exists, and returns $\$$, otherwise.

\item Otherwise,  $f$ calls itself recursively on
  $\eliminateState\,\Simp\,(M,q)$, where $q$ is the least element (in the
  standard ordering on symbols) of $Q_M-(\{s_M\}\cup A_M)$.
\end{itemize}

\begin{proposition}
Suppose $M$ is an RFA and
$\Simp\in\Reg\fun\Reg$ has the property that,
for all $\alpha\in\Reg$, $L(\Simp\,\alpha) = L(\alpha)$ and
$\alphabet(\Simp\,\alpha)\sub\alphabet\,\alpha$.
Then:
\begin{enumerate}[\quad(1)]
\item $L(\rfaToReg\,\Simp\,M) = L(M)$; and 

\item $\alphabet(\rfaToReg\,\Simp\,M) \sub \alphabet\,M$.
\end{enumerate}
\end{proposition}

Finally, we define our RFA to regular expression conversion algorithm/function:
\index{regular expression finite automaton!rfaToReg@$\faToReg$}%
\begin{gather*}
\faToReg\in(\Reg\fun\Reg)\fun\FA\fun\Reg .  
\end{gather*}
$\faToReg$ takes in $\Simp\in\Reg\fun\Reg$, and returns
\begin{displaymath}
\rfaToReg\,\Simp \circ \faToRFA\,\Simp .
\end{displaymath}

\begin{proposition}
Suppose $M$ is an FA and
$\Simp\in\Reg\fun\Reg$ has the property that,
for all $\alpha\in\Reg$, $L(\Simp\,\alpha) = L(\alpha)$ and
$\alphabet(\Simp\,\alpha)\sub\alphabet\,\alpha$.
Then:
\begin{enumerate}[\quad(1)]
\item $L(\faToReg\,\Simp\,M) = L(M)$; and 

\item $\alphabet(\faToReg\,\Simp\,M) \sub \alphabet\,M$.
\end{enumerate}
\end{proposition}

The Forlan module \texttt{RFA} includes functions
\begin{verbatim}
val toReg             : (reg -> reg) -> rfa -> reg
val faToReg           : (reg -> reg) -> fa -> reg
val faToRegPerms      : int option * (reg -> reg) -> fa -> reg
val faToRegPermsTrace : int option * (reg -> reg) -> fa -> reg
\end{verbatim}
\index{RFA@\texttt{RFA}!toReg@\texttt{toReg}}%
\index{RFA@\texttt{RFA}!faToReg@\texttt{faToReg}}%
\index{RFA@\texttt{RFA}!faToRegPerms@\texttt{faToRegPerms}}%
\index{RFA@\texttt{RFA}!faToRegPermsTrace@\texttt{faToRegPermsTrace}}%
The function \texttt{toReg} corresponds to $\rfaToReg$.
The function \texttt{faToReg} is the implementation of $\faToReg$.  If
$\Simp$ is a simplification function and $M$ is an FA, then
$\mathtt{faToRegPerms}\,(\mathtt{NONE},\Simp)\,M$ applies $\faToReg$
to all of the FAs $N$ that can be formed by renaming $M$'s states
using bijections (i.e., permutations) from $Q_M$ to $Q_M$, and returns
the simplest answer found (ties in complexity are broken by selecting
the smallest regular expression in our total ordering on regular
expressions.)
$\mathtt{faToRegPerms}\,(\mathtt{SOME}\,n,\Simp)\,M$, for $n\geq 1$,
works similarly, except that only $n$ ways of renaming $M$'s state are
considered.  And \texttt{faToRegPermsTrace} is like
\texttt{faToRegPerms} except that it explains what it's doing.  The
functions \texttt{faToReg}, \texttt{faToRegPerms} and
\texttt{faToRegTrace} are also available in the top-level environment
with those names:
\begin{verbatim}
val faToReg           : (reg -> reg) -> fa -> reg
val faToRegPerms      : int option * (reg -> reg) -> fa -> reg
val faToRegPermsTrace : int option * (reg -> reg) -> fa -> reg
\end{verbatim}
\index{regular expression!faToReg@\texttt{faToReg}}%
\index{regular expression!faToRegPerms@\texttt{faToRegPerms}}%
\index{regular expression!faToRegPermsTrace@\texttt{faToRegPermsTrace}}%
\index{finite automaton!faToReg@\texttt{faToReg}}%
\index{finite automaton!faToRegPerms@\texttt{faToRegPerms}}%
\index{finite automaton!faToRegPermsTrace@\texttt{faToRegPermsTrace}}%

Suppose \texttt{fa} is the FA
\begin{center}
\input{chap-3.12-fig30.eepic}
\end{center}
which accepts $\setof{w\in\{\mathsf{0,1}\}^*}{w\eqtxt{has
an even number of}\zerosf\eqtxt{and}\onesf\eqtxtn{'s}}$.
converting \texttt{fa} into a regular expression using
\texttt{faToReg} and $\weaklySimplify$ yields a fairly complicated answer:
\input{chap-3.12-forlan3c}
But by using \texttt{faToRegPerms}, we can do much better:
\input{chap-3.12-forlan3d}
By using \texttt{faToRegPermsTrace}, we can learn that this answer was
found using the renaming
\begin{gather*}
\mathsf{(A, D), (B, A), (C, B), (D, C)}
\end{gather*}
of $M$'s states.  That is, it was found by making $M$ into
a standard RFA, with new start and accepting states,
and then eliminating the states corresponding to
$\Bsf$, $\Csf$, $\Dsf$ and $\Asf$, in that order.

\subsection{Characterization of Regular Languages}

\index{characterization of regular languages}%
\index{regular languages: characterization}%
Since we have algorithms for converting back and forth between
regular expressions and finite automata, as well as algorithms for
converting FAs to RFAs, RFAs to regular expressions,
FAs to EFAs, EFAs to NFAs, and NFAs to DFAs,
we have the following theorem:
\begin{theorem}
\label{RegularEquiv}
Suppose $L$ is a language.  The following statements are equivalent:
\begin{itemize}
\item $L$ is regular;

\item $L$ is generated by a regular expression;

\item $L$ is accepted by a regular expression finite automaton;

\item $L$ is accepted by a finite automaton;

\item $L$ is accepted by an EFA;

\item $L$ is accepted by an NFA; and

\item $L$ is accepted by a DFA.
\end{itemize}
\end{theorem}

\subsection{More Closure Properties/Algorithms}

\index{language!intersection}%
\index{empty string finite automaton!intersection}%
Consider the EFAs $M_1$ and $M_2$:
\begin{center}
\input{chap-3.12-fig14.eepic}
\end{center}
How can we construct an EFA $N$ such that $L(N)=L(M_1)\cap L(M_2)$?
The idea is to make the states of $N$ represent pairs of the form
$(q,r)$, where $q\in Q_{M_1}$ and $r\in Q_{M_2}$.

In order to define our intersection operation on EFAs, we first need
to define two auxiliary functions.  Suppose $M_1$ and $M_2$ are EFAs.
We define a function
\begin{gather*}
\nextSym_{M_1,M_2}\in
(Q_{M_1}\times Q_{M_2})\times\Sym \fun
\powset(Q_{M_1}\times Q_{M_2})
\end{gather*}
by $\nextSym_{M_1,M_2}((q,r),a)={}$
\begin{gather*}
\setof{(q',r')}{q,a\fun q'\in T_{M_1}\eqtxt{and}
r,a\fun r'\in T_{M_2}} .
\end{gather*}
We often abbreviate $\nextSym_{M_1,M_2}$ to $\nextSym$.
If $M_1$ and $M_2$ are our example EFAs, then
$\nextSym((\Asf,\Asf),\zerosf) = \emptyset$ and
$\nextSym((\Asf,\Bsf),\zerosf) = \{(\Asf,\Bsf)\}$.
Suppose $M_1$ and $M_2$ are EFAs.  We define a function
\begin{gather*}
\nextEmp_{M_1,M_2}\in
(Q_{M_1}\times Q_{M_2})\fun\powset(Q_{M_1}\times Q_{M_2})
\end{gather*}
by $\nextEmp_{M_1,M_2}(q,r)={}$
\begin{gather*}
\setof{(q',r)}{q,\%\fun q'\in T_{M_1}} \cup
\setof{(q,r')}{r,\%\fun r'\in T_{M_2}} .
\end{gather*}
We often abbreviate $\nextEmp_{M_1,M_2}$ to $\nextEmp$.  If $M_1$ and
$M_2$ are our example EFAs, then $\nextEmp(\Asf,\Asf) =
\{\mathsf{(B,A),(A,B)}\}$, $\nextEmp(\Asf,\Bsf) = \{(\Bsf,\Bsf)\}$,
$\nextEmp(\Bsf,\Asf) = \{(\Bsf,\Bsf)\}$ and $\nextEmp(\Bsf,\Bsf) =
\emptyset$.

Now, we define a function/algorithm
\index{empty string finite automaton!inter@$\inter$}%
$\inter\in\EFA\times\EFA\fun\EFA$ such that
$L(\inter(M_1,M_2))=L(M_1)\cap L(M_2)$, for all $M_1,M_2\in\EFA$.
Given EFAs $M_1$ and $M_2$, $\inter(M_1,M_2)$, the \emph{intersection of}
$M_1$ \emph{and} $M_2$, is the EFA $N$ that is constructed as follows.
First, we let $\Sigma=\alphabet\,M_1\cap\alphabet\,M_2$.
Next, we generate the least subset $X$ of $Q_{M_1}\times Q_{M_2}$
such that
\begin{itemize}
\item $(s_{M_1},s_{M_2})\in X$;

\item for all $q\in Q_{M_1}$, $r\in Q_{M_2}$ and $a\in\Sigma$,
if $(q,r)\in X$, then $\nextSym((q,r),a)\sub X$; and

\item for all $q\in Q_{M_1}$ and $r\in Q_{M_2}$,
if $(q,r)\in X$, then $\nextEmp(q,r)\sub X$.
\end{itemize}
Then, the EFA $N$ is defined by:
\begin{itemize}
\item $Q_N=
\setof{\langle q,r\rangle}{(q,r)\in X}$;

\item $s_N=\langle s_{M_1},s_{M_2}\rangle$;

\item $A_N=\setof{\langle q,r\rangle}{(q,r)\in X\eqtxt{and}
q\in A_{M_1}\eqtxt{and}r\in A_{M_2}}$; and

\item $T_N={}$
  \begin{align*}
    &\quad \{\,\langle q,r\rangle,a\fun\langle
    q',r'\rangle\mid(q,r)\in X\eqtxt{and}
    a\in\Sigma\eqtxt{and}\\
    &\hspace{3.45cm}(q',r')\in\nextSym((q,r),a)\,\} \\
    &\cup
    \{\,\langle q,r\rangle,\%\fun\langle q',r'\rangle\mid(q,r)\in
    X\eqtxt{and} \\
    &\hspace{3.6cm}(q',r')\in\nextEmp(q,r)\,\}.
  \end{align*}
\end{itemize}

Suppose $M_1$ and $M_2$ are our example EFAs.
Then $\inter(M_1,M_2)$ is
\begin{center}
\input{chap-3.12-fig15.eepic}
\end{center}

\begin{theorem}
For all $M_1,M_2\in\EFA$:
\begin{itemize}
\item $L(\inter(M_1,M_2))=L(M_1)\cap L(M_2)$; and

\item $\alphabet(\inter(M_1,M_2))\sub \alphabet\,M_1\cap\alphabet\,M_2$.
\end{itemize}
\end{theorem}

\index{nondeterministic finite automaton!intersection}%
\index{nondeterministic finite automaton!inter@$\inter$}%
\begin{proposition}
For all $M_1,M_2\in\NFA$, $\inter(M_1,M_2)\in\NFA$.
\end{proposition}

\index{deterministic finite automaton!intersection}%
\index{deterministic finite automaton!inter@$\inter$}%
\begin{proposition}
For all $M_1,M_2\in\DFA$:
\begin{enumerate}[\quad(1)]
\item $\inter(M_1,M_2)\in\DFA$.

\item $\alphabet(\inter(M_1,M_2)) = \alphabet\,M_1\cap\alphabet\,M_2$.
\end{enumerate}
\end{proposition}

\index{deterministic finite automaton!complementation}%
\index{deterministic finite automaton!complement@$\mycomplement$}%
Next, we define a function $\mycomplement\in\DFA\times\Alp\fun\DFA$
such that, for all $M\in\DFA$ and $\Sigma\in\Alp$,
\begin{gather*}
L(\mycomplement(M,\Sigma)) = (\alphabet(L(M))\cup\Sigma)^*-L(M) .
\end{gather*}
In the common case when $L(M)\sub\Sigma^*$, we will have that
$\alphabet(L(M))\sub\Sigma$, and thus that
$(\alphabet(L(M))\cup\Sigma)^*=\Sigma^*$.  Hence, it will be the case
that
\begin{gather*}
L(\mycomplement(M,\Sigma)) = \Sigma^*-L(M) .
\end{gather*}

Given a DFA $M$ and an alphabet $\Sigma$, $\mycomplement(M,\Sigma)$,
the \emph{complement of} $M$ \emph{with reference to} $\Sigma$,
is the DFA $N$ that is produced as follows.  First, we let the DFA
$M'=\determSimplify(M,\Sigma)$.  Thus:
\begin{itemize}
\item $M'$ is equivalent to $M$; and

\item $\alphabet\,M' = \alphabet(L(M))\cup\Sigma$.
\end{itemize}
Then, we define $N$ by:
\begin{itemize}
\item $Q_N = Q_{M'}$;

\item $s_N = s_{M'}$;

\item $A_N = Q_{M'} - A_{M'}$; and

\item $T_N = T_{M'}$.
\end{itemize}
Then, for all $w\in(\alphabet\,M')^*=
(\alphabet\,N)^*=(\alphabet(L(M))\cup\Sigma)^*$,
\begin{align*}
w\in L(N) &\myiff \delta_N(s_N, w)\in A_N \\
&\myiff \delta_N(s_N, w)\in Q_{M'}-A_{M'} \\
&\myiff \delta_{M'}(s_{M'}, w)\not\in A_{M'} \\
&\myiff w\not\in L(M') \\
&\myiff w\not\in L(M) .
\end{align*}
Hence:

\begin{theorem}
For all $M\in\DFA$ and $\Sigma\in\Alp$:
\begin{itemize}
\item $L(\mycomplement(M,\Sigma)) = (\alphabet(L(M))\cup\Sigma)^*-L(M)$; and

\item $\alphabet(\mycomplement(M,\Sigma)) = \alphabet(L(M))\cup\Sigma$.
\end{itemize}
\end{theorem}

For example, suppose the DFA $M$ is
\begin{center}
\input{chap-3.12-fig16.eepic}
\end{center}
Then $\determSimplify(M,\{\twosf\})$ is the DFA
\begin{center}
\input{chap-3.12-fig17.eepic}
\end{center}
Thus $\mycomplement(M,\{\twosf\})$ is
\begin{center}
\input{chap-3.12-fig18.eepic}
\end{center}

Let $X=\setof{w\in\{\mathsf{0,1}\}^*}{\mathsf{000}\eqtxt{is not a
    substring of}w}$.  Then $L(\mycomplement(M,\{\twosf\}))$ is
\begin{alignat*}{2}
&\mathrel{\hspace*{.3cm}} (\alphabet(L(M))\cup\{\twosf\})^*-L(M) \\
&=(\{\mathsf{0,1}\}\cup\{\twosf\})^* - X \\
&=\setof{w\in\{\mathsf{0,1,2}\}^*}{w\not\in X} \\
&=\setof{w\in\{\mathsf{0,1,2}\}^*}{2\in\alphabet\,w\eqtxt{or}
\mathsf{000}\eqtxt{is a substring of}w} .
\end{alignat*}

\index{language!difference}%
\index{deterministic finite automaton!difference}%
\index{deterministic finite automaton!minus@$\minus$}%
We define a function/algorithm $\minus\in\DFA\times\DFA\fun\DFA$ by:
$\minus(M_1,M_2)$, the \emph{difference of} $M_1$ \emph{and} $M_2$, is
\begin{gather*}
\inter(M_1,\mycomplement(M_2,{\alphabet\,M_1})) .
\end{gather*}

\begin{theorem}
\label{DFAMinusTheorem}
For all $M_1,M_2\in\DFA$:
\begin{enumerate}[\quad(1)]
\item $L(\minus(M_1,M_2)) = L(M_1)-L(M_2)$; and

\item $\alphabet(\minus(M_1,M_2)) = \alphabet\,M_1$.
\end{enumerate}
\end{theorem}

\begin{proof}
Suppose $w\in\Str$.  Then:
\begin{align*}
&\hspace{.95cm} w\in L(\minus(M_1,M_2)) \\
&\myiff w\in L(\inter(M_1,\mycomplement(M_2,\alphabet\,M_1))) \\
&\myiff w\in L(M_1)\eqtxt{and}w\in L(\mycomplement(M_2,\alphabet\,M_1)) \\
&\myiff w\in L(M_1)\eqtxt{and}w\in(\alphabet(L(M_2))\cup\alphabet\,M_1)^*\eqtxt{and} \\
&\qquad\;\; w\not\in L(M_2) \\
&\myiff w\in L(M_1)\eqtxt{and}w\not\in L(M_2) \\
&\myiff w\in L(M_1)-L(M_2) .
\end{align*}
\end{proof}

To see why the second argument to $\mycomplement$ is
$\alphabet\,M_1$, in the definition of $\minus(M_1,M_2)$, look at
the ``if'' direction of the second-to-last step of the preceding
proof: since $w\in L(M_1)$, we have that $w\in(\alphabet\,M_1)^*$, so
that $w\in (\alphabet(L(M_2))\cup\alphabet(M_1))^*$.

For example, let $M_1$ and $M_2$ be the EFAs
\begin{center}
\input{chap-3.12-fig14.eepic}
\end{center}
Since $L(M_1)=\{\zerosf\}^*\{\onesf\}^*$ and
$L(M_2)=\{\onesf\}^*\{\zerosf\}^*$, we have that
\begin{displaymath}
L(M_1)-L(M_2)=\{\zerosf\}^*\{\onesf\}^*-\{\onesf\}^*\{\zerosf\}^* =
\{\zerosf\}\{\zerosf\}^*\{\onesf\}\{\onesf\}^* .
\end{displaymath}
Define DFAs $N_1$ and $N_2$ by:
\begin{align*}
N_1 &= \nfaToDFA(\efaToNFA\,M_1) , \eqtxt{and} \\
N_2 &= \nfaToDFA(\efaToNFA\,M_2) .
\end{align*}
Thus we have that
\begin{alignat*}{2}
L(N_1) &= L(\nfaToDFA(\efaToNFA(M_1))) \\
       &= L(\efaToNFA(M_1)) && \by{Theorem~\ref{NFAToDFATheorem}} \\
       &= L(M_1) && \by{Theorem~\ref{EFAToNFATheorem}} \\
L(N_2) &= L(\nfaToDFA(\efaToNFA(M_2))) \\
       &= L(\efaToNFA(M_2)) && \by{Theorem~\ref{NFAToDFATheorem}} \\
       &= L(M_2) && \by{Theorem~\ref{EFAToNFATheorem}} .
\end{alignat*}
Let the DFA $N=\minus(N_1,N_2)$.
Then
\begin{alignat*}{2}
L(N) &= L(\minus(N_1,N_2)) \\
     &= L(N_1)-L(N_2) && \by{Theorem~\ref{DFAMinusTheorem}} \\
     &= L(M_1)-L(M_2) \\
     &= \{\zerosf\}\{\zerosf\}^*\{\onesf\}\{\onesf\}^* .
\end{alignat*}

Next, we consider the reversal of languages, regular expressions,
finite automata and empty-string finite automata.
The \emph{reversal of}
\index{language!reversal}%
a language $L$ ($L^R\in\Lan$)
\index{ reversal@$\cdot^R$}%
\index{language! reversal@$\cdot^R$}%
is $\setof{w}{w^R\in L} = \setof{w^R}{w\in L}$.  I.e., $L^R$ is formed
by reversing all of the elements of $L$.  For example, $\{\mathsf{011,
1011}\}^R = \{\mathsf{110, 1101}\}$.

The module \texttt{StrSet}
\index{StrSet@\texttt{StrSet}}%
defines the function
\begin{verbatim}
val rev : str set -> str set
\end{verbatim}
\index{StrSet@\texttt{StrSet}!rev@\texttt{rev}}%
that implements language reversal. E.g., we can
proceed as follows:
\input{chap-3.12-forlan4}

Define $\rev\in\Reg\fun\Reg$ by recursion:
\index{regular expression!reversal}%
\index{rev@$\rev$}%
\index{regular expression!rev@$\rev$}%
\begin{align*}
\rev\,\% &= \%; \\
\rev\,\$ &= \$; \\
\rev\,a &= a, \eqtxt{for all}a\in\Sym; \\
\rev(\alpha^*) &= (\rev\,\alpha)^*, \eqtxt{for all}\alpha\in\Reg;\\
\rev(\alpha\,\beta) &= \rev\,\beta\,\rev\,\alpha ,
\eqtxt{for all}\alpha,\beta\in\Reg; \eqtxt{and} \\
\rev(\alpha+\beta) &= \rev\,\alpha + \rev\,\beta ,
\eqtxt{for all}\alpha,\beta\in\Reg .
\end{align*}
We say that $\rev\,\alpha$ is \emph{the reversal of} $\alpha$.
For example $\rev(\mathsf{01+(10)^*}) = \mathsf{10 + (01)^*}$.

\begin{theorem}
\label{RegExpRev}
For all $\alpha\in\Reg$:
\begin{itemize}
\item $L(\rev\,\alpha) = L(\alpha)^R$; and

\item $\alphabet(\rev\,\alpha) = \alphabet\,\alpha$.
\end{itemize}
\end{theorem}

\begin{proof}
By induction on $\alpha$.
\end{proof}

We can also define a reversal operation on FAs and EFAs.  The idea is
to reverse all of the transitions, add a new start state, with
$\%$-transitions to all of the original accepting states, and make the
original start state be the unique accepting state.  Formally, we
define a function $\rev\in\FA\fun\FA$ as
\index{finite automaton!reversal}%
\index{empty-string finite automaton!reversal}%
\index{rev@$\rev$}%
\index{finite automaton!rev@$\rev$}%
\index{empty-string finite automaton!rev@$\rev$}%
follows.
Given an FA $M$, $\rev\,M$, \emph{the reversal of} $M$,
is the FA $N$ such that
\begin{itemize}
\item $Q_N=\{\Asf\}\cup\setof{\langle q\rangle}{q\in Q_M}$;

\item $s_N=\Asf$;

\item $A_N=\{\langle s_M\rangle\}$; and

\item $T_N=\setof{(\langle r\rangle, x^R, \langle q\rangle)}{(q, x, r)\in T_M} \cup
\setof{(\Asf, \%, \langle q\rangle)}{q\in A_M}$.
\end{itemize}
It is easy to see that, for all $M\in\EFA$, $\rev\,M\in\EFA$.

For example, if $M$ is the FA
\begin{center}
\input{chap-3.12-fig23.eepic}
\end{center}
then $\rev\,M$ is
\begin{center}
\input{chap-3.12-fig24.eepic}
\end{center}
We have that $\mathsf{012345}$ and $\mathsf{0123450123}$ are in $L(M)$,
and $\mathsf{543210}$ and $\mathsf{3210543210}$ are in $L(\rev\,M)=L(M)^R$.

\begin{theorem}
\label{FARev}
For all $M\in\FA$:
\begin{itemize}
\item $L(\rev\,M) = L(M)^R$; and

\item $\alphabet(\rev\,M) = \alphabet\,M$.
\end{itemize}
\end{theorem}

Next, we consider the prefix-, suffix- and substring-closures of
\index{language!prefix-closure}%
\index{language!suffix-closure}%
\index{language!substring-closure}%
languages, as well as the associated operations on automata.  Suppose
$L$ is a language.  Then:
\begin{itemize}
\item The \emph{prefix-closure} of $L$ ($L^P$) is $\setof{x}{xy\in L,
\eqtxt{for some}y\in\Str}$.  I.e., $L^P$ is all of the prefixes
of elements of $L$.  E.g., $\{\mathsf{012,3}\}^P =
\{\mathsf{\%,0,01,012,3}\}$.

\item The \emph{suffix-closure} of $L$ ($L^S$) is $\setof{y}{xy\in L,
\eqtxt{for some}x\in\Str}$.  I.e., $L^S$ is all of the suffixes
of elements of $L$.  E.g., $\{\mathsf{012,3}\}^S =
\{\mathsf{\%,2,12,012,3}\}$.

\item The \emph{substring-closure} of $L$ ($L^\SSop$) is $\setof{y}{xyz\in L,
\eqtxt{for some}x,z\in\Str}$.  I.e., $L^\SSop$ is all of the substrings
of elements of $L$.  E.g., $\{\mathsf{012,3}\}^\SSop =
\{\mathsf{\%, 0, 1, 2, 01, 12, 012, 3}\}$.
\end{itemize}

The following proposition shows that we can express suffix- and
substring-closure in terms of prefix-closure and language reversal.

\begin{proposition}
\label{PrefixSuffixSubstringClosure}
For all languages $L$:
\begin{itemize}
\item $L^S = ((L^R)^P)^R$; and

\item $L^\SSop = (L^P)^S$.
\end{itemize}
\end{proposition}

The module \texttt{StrSet}
\index{StrSet@\texttt{StrSet}}%
defines the functions
\begin{verbatim}
val prefix    : str set -> str set
val suffix    : str set -> str set
val substring : str set -> str set
\end{verbatim}
\index{StrSet@\texttt{StrSet}!prefix@\texttt{prefix}}%
\index{StrSet@\texttt{StrSet}!suffix@\texttt{suffix}}%
\index{StrSet@\texttt{StrSet}!substring@\texttt{substring}}%
that implement prefix-, suffix- and substring-closure. 
E.g., we can proceed as follows:
\input{chap-3.12-forlan4a}

Now, we define a function $\prefix\in\EFA\fun\EFA$ such that
\index{prefix@$\prefix$}%
\index{empty-string finite automaton!prefix@$\prefix$}%
\index{empty-string finite automaton!prefix-closure}%
\index{prefix-closure!empty-string finite automaton}%
$L(\prefix\,M)=L(M)^P$, for all $M\in\EFA$.  Given an EFA $M$,
$\prefix\,M$, \emph{the prefix-closure of} $M$,
is the EFA $N$ that is constructed as follows.
First, we simplify $M$, producing an EFA $M'$ that is equivalent to
$M$ and either has no useless states, or consists of a single dead
state and no-transitions.
If $M'$ has no useless states, then we let $N$ be the same as $M'$
except that $A_N = Q_N=Q_{M'}$,
i.e., all states of $N$ are accepting states.
If $M'$ consists of a single dead state and no transitions,
then we let $N=M'$.

For example, suppose $M$ is the EFA
\begin{center}
\input{chap-3.12-fig19.eepic}
\end{center}
so that $L(M)=\{\mathsf{001}\}^*$.  Then
$\prefix\,M$ is the EFA
\begin{center}
\input{chap-3.12-fig20.eepic}
\end{center}
which accepts
$\{\mathsf{001}\}^*\{\%,\zerosf,\zerosf\zerosf\}$.

\begin{theorem}
\label{EFAPrefix}
For all $M\in\EFA$:
\begin{itemize}
\item $L(\prefix\,M) = L(M)^P$; and

\item $\alphabet(\prefix\,M) = \alphabet(L(M))$.
\end{itemize}
\end{theorem}

\begin{proposition}
For all $M\in\NFA$, $\prefix\,M\in\NFA$.
\end{proposition}
\index{nondeterministic finite automaton!prefix@$\prefix$}%
\index{nondeterministic finite automaton!prefix-closure}%

Now we can define suffix-closure and substring-closure
operations on EFAs as follows.  The functions $\suffix,\substring\in
\EFA\fun\EFA$ are defined by:
\index{empty-string finite automaton!suffix@$\suffix$}%
\index{empty-string finite automaton!substring@$\substring$}%
\index{empty-string finite automaton!suffix-closure}%
\index{empty-string finite automaton!substring-closure}%
\begin{align*}
\suffix\,M &= \rev(\prefix(\rev\,M))) , \eqtxt{and} \\
\substring\,M &= \suffix(\prefix\,M)) .
\end{align*}

\begin{theorem}
For all $M\in\EFA$:
\begin{itemize}
\item $L(\suffix\,M) = L(M)^S$; and

\item $L(\substring\,M) = L(M)^\SSop$.
\end{itemize}
\end{theorem}

Next, we consider the renaming of regular expressions and finite
automata using bijections on symbols.  If $x$ is a string and $f$ is a
bijection from a set of symbols that is a superset of $\alphabet\,x$
(maybe $\alphabet\,x$ itself, i.e., the symbols appearing in $x$) to
some set of symbols, then the \emph{renaming of} $x$ \emph{using} $f$
($x^f\in\Str$) is the result of applying $f$ to \index{alphabet
  renaming!string}%
\index{string!alphabet renaming}%
\index{ power@$\cdot^\cdot$}%
\index{string! power@$\cdot^\cdot$}%
each symbol of $x$.  For example, if
$f=\mathsf{\{(0, 1), (1, 2), (2, 3)\}}$, then $\%^f=\%$ and
$(\mathsf{01102})^f=\mathsf{12213}$.

If $L$ is a language, and $f$ is a bijection from a set of symbols
that is a superset of $\alphabet\,L$ (maybe $\alphabet\,L$ itself)
to some set of symbols, then the \emph{renaming of} $L$ \emph{using}
\index{language!alphabet renaming}%
\index{ power@$\cdot^\cdot$}%
\index{language! power@$\cdot^\cdot$}%
$f$ ($L^f\in\Lan$) is formed by applying $f$ to every symbol of every string
of $L$.  For example, if $L=\{\mathsf{012, 12}\}$ and
$f=\mathsf{\{(0, 1), (1, 2), (2, 3)\}}$, then $L^f=\{\mathsf{123,
23}\}$.

\begin{exercise}
Suppose
$L = \setof{w\in\{\mathsf{0,1,2}\}^*}{w\eqtxt{has an even number
    of occurrences of}\zerosf}$. Suppose $f$ is the bijection from
$\{\mathsf{0,1,2}\}$ to $\{\mathsf{0,1,2}\}$ defined by:
$f\,\zerosf = \onesf$, $f\,\onesf = \zerosf$, and
$f\,\twosf = \twosf$. Show that $L^f = 
\setof{w\in\{\mathsf{0,1,2}\}^*}{w\eqtxt{has an even number
    of occurrences of }\onesf}$.
\end{exercise}

The module \texttt{Str}
\index{Str@\texttt{Str}}%
defines the function
\begin{verbatim}
val renameAlphabet : str * sym_rel -> str
\end{verbatim}
that implements alphabet renaming for strings.
And the module \texttt{StrSet}
\index{StrSet@\texttt{StrSet}}%
defines the function
\begin{verbatim}
val renameAlphabet : str set * sym_rel -> str set
\end{verbatim}
\index{StrSet@\texttt{StrSet}!renameAlphabet@\texttt{renameAlphabet}}%
that implements alphabet renaming for languages.
E.g., we can proceed as follows:
\input{chap-3.12-forlan4b}

Let $X=\setof{(\alpha,f)}{\alpha\in\Reg\eqtxt{and}f\eqtxtl{is a
bijection from a set of symbols that}\eqtxtr{is a superset
of}\alphabet\,\alpha\eqtxtl{to some set of symbols}}$.
Then, the function $\renameAlphabet\in X\fun\Reg$ takes in a pair
$(\alpha,f)$ and
\index{regular expression!alphabet renaming}%
\index{renameAlphabet@$\renameAlphabet$}%
\index{regular expression!renameAlphabet@$\renameAlphabet$}%
returns the regular expression produced from $\alpha$ by renaming each
sub-tree of the form $a$, for $a\in\Sym$, to $f(a)$.
For example, $\renameAlphabet(\mathsf{012+12},
\mathsf{\{(0, 1), (1, 2), (2, 3)\}}) =
\mathsf{123+23}$.

\begin{theorem}
For all $\alpha\in\Reg$ and bijections $f$ from sets of symbols that
are supersets of $\alphabet\,\alpha$ to sets of symbols:
\begin{itemize}
\item $L(\renameAlphabet(\alpha,f)) = L(\alpha)^f$; and

\item $\alphabet(\renameAlphabet(\alpha,f)) =
\setof{f\,a}{a\in\alphabet\,\alpha}$.
\end{itemize}
\end{theorem}

For example, if $f=\mathsf{\{(0, 1), (1, 2), (2, 3)\}}$, then
\begin{align*}
L(\renameAlphabet(\mathsf{012+12}, f)) &=
L(\mathsf{012+12})^f=\{\mathsf{012,12}\}^f \\
&= \{\mathsf{123,23}\} .
\end{align*}

Let $X=\setof{(M,f)}{M\in\FA\eqtxt{and}f\eqtxtl{is a
bijection from a set of symbols that}\eqtxtr{is a superset
of}\alphabet\,M\eqtxtl{to some set of symbols}}$.
Then, the function $\renameAlphabet\in X\fun\FA$ takes in a pair $(M,f)$ and
\index{finite automaton!alphabet renaming}%
\index{empty-string finite automaton!alphabet renaming}%
\index{nondeterministic finite automaton!alphabet renaming}%
\index{deterministic finite automaton!alphabet renaming}%
\index{renameAlphabet@$\renameAlphabet$}%
\index{finite automaton!renameAlphabet@$\renameAlphabet$}%
\index{empty-string finite automaton!renameAlphabet@$\renameAlphabet$}%
\index{nondeterministic finite automaton!renameAlphabet@$\renameAlphabet$}%
\index{deterministic finite automaton!renameAlphabet@$\renameAlphabet$}%
returns the FA produced from $M$ by renaming each symbol of each
label of each transition using $f$.
For example, if $M$ is the FA
\begin{center}
\input{chap-3.12-fig21.eepic}
\end{center}
and $f=\{\mathsf{(0,1), (1,2)}\}$, then
$\renameAlphabet(M,f)$ is the FA
\begin{center}
\input{chap-3.12-fig22.eepic}
\end{center}

\begin{theorem}
For all $M\in\FA$ and bijections $f$ from sets of symbols that
are supersets of $\alphabet\,M$ to sets of symbols:
\begin{itemize}
\item $L(\renameAlphabet(M,f)) = L(M)^f$;

\item $\alphabet(\renameAlphabet(M,f)) =
\setof{f\,a}{a\in\alphabet\,M}$;

\item if $M$ is an EFA, then $\renameAlphabet(M,f)$ is an EFA;

\item if $M$ is an NFA, then $\renameAlphabet(M,f)$ is an NFA; and

\item if $M$ is a DFA, then $\renameAlphabet(M,f)$ is a DFA.
\end{itemize}
\end{theorem}

\begin{theorem}
\label{ClosurePropTheorem}
Suppose $L,L_1,L_2\in\RegLan$.
Then:
\begin{enumerate}[\quad(1)]
\item $L_1\cup L_2\in\RegLan$;

\item $L_1L_2\in\RegLan$;

\item $L^*\in\RegLan$;

\item $L_1\cap L_2\in\RegLan$;

\item $L_1 - L_2\in\RegLan$;

\item $L^R\in\RegLan$;

\item $L^P\in\RegLan$;

\item $L^S\in\RegLan$;

\item $L^\SSop\in\RegLan$; and

\item $L^f\in\RegLan$, where $f$ is a bijection from a set of symbols
that is a superset of $\alphabet\,L$ to some set of symbols.
\end{enumerate}
\end{theorem}

\begin{proof}
Parts (1)--(10) hold because of the operations $\union$, $\concat$
and $\closure$ on FAs, the operation $\inter$ on EFAs, the
operation $\minus$ on DFAs, the operation $\rev$ on regular
expressions, the operations $\prefix$, $\suffix$ and $\substring$ on
EFAs, the operation $\renameAlphabet$ on regular expressions, and
Theorem~\ref{RegularEquiv}.
\end{proof}

The Forlan module \texttt{EFA} defines the function/algorithm
\begin{verbatim}
val inter : efa * efa -> efa
\end{verbatim}
which corresponds to $\inter$.  It is also inherited by the
modules \texttt{DFA} and \texttt{NFA}.

The Forlan module DFA defines the functions
\begin{verbatim}
val complement : dfa * sym set -> dfa
val minus      : dfa * dfa -> dfa
\end{verbatim}
which correspond to $\mycomplement$ and $\minus$.

Suppose the identifiers \texttt{efa1} and \texttt{efa2} of type \texttt{efa}
are bound to our example EFAs $M_1$ and $M_2$:
\begin{center}
\input{chap-3.12-fig14.eepic}
\end{center}
Then, we can construct $\inter(M_1,M_2)$ as follows:
\input{chap-3.12-forlan6}
Thus \texttt{efa} is bound to the EFA
\begin{center}
\input{chap-3.12-fig15.eepic}
\end{center}

Suppose \texttt{dfa} is bound to our example DFA $M$
\begin{center}
\input{chap-3.12-fig16.eepic}
\end{center}
Then we can construct the DFA $\mycomplement(M,\{\twosf\})$
as follows:
\input{chap-3.12-forlan8}
Thus \texttt{dfa'} is bound to the DFA
\begin{center}
\input{chap-3.12-fig18.eepic}
\end{center}

Suppose the identifiers \texttt{efa1} and \texttt{efa2} of type \texttt{efa}
are bound to our example EFAs $M_1$ and $M_2$:
\begin{center}
\input{chap-3.12-fig14.eepic}
\end{center}
We can construct an EFA that accepts $L(M_1)-L(M_2)$ as follows:
\input{chap-3.12-forlan10}

Next, we see how we can carry out the reversal and alphabet-renaming
of regular expressions in Forlan.  The Forlan module \texttt{Reg}
defines the functions
\begin{verbatim}
val rev            : reg -> reg
val renameAlphabet : reg * sym_rel -> reg
\end{verbatim}
\index{Reg@\texttt{Reg}!rev@\texttt{rev}}%
\index{Reg@\texttt{Reg}!renameAlphabet@\texttt{renameAlphabet}}%
which correspond to $\rev$ and $\renameAlphabet$.
(\texttt{renameAlphabet} issues an error message and raises
an exception if its second argument isn't legal).
Here is an example of how these functions can be used:
\input{chap-3.12-forlan12}

Next, we see how we can carry out the reversal of FAs and EFAs in
Forlan.  The Forlan module \texttt{FA} defines the function
\begin{verbatim}
val rev : fa -> fa
\end{verbatim}
\index{FA@\texttt{FA}!rev@\texttt{rev}}%
which corresponds to $\rev$.
It is also inherited by the module \texttt{EFA}.
\index{EFA@\texttt{EFA}!rev@\texttt{rev}}%
Here is an example of how this function can be used:
\input{chap-3.12-forlan12a}

Next, we see how we can carry out the prefix-closure of EFAs and NFAs in
Forlan.  The Forlan module \texttt{EFA} defines the function
\begin{verbatim}
val prefix : efa -> efa
\end{verbatim}
\index{EFA@\texttt{EFA}!prefix@\texttt{prefix}}%
which corresponds to $\prefix$.
It is also inherited by the module \texttt{NFA}.
\index{NFA@\texttt{NFA}!prefix@\texttt{prefix}}%
Here is an example of how one of these functions can be used:
\input{chap-3.12-forlan13}

Finally, we see how we can carry out alphabet-renaming of finite
automata using Forlan.
The Forlan module \texttt{FA} defines the function
\begin{verbatim}
val renameAlphabet : FA * sym_rel -> FA
\end{verbatim}
\index{FA@\texttt{FA}!renameAlphabet@\texttt{renameAlphabet}}%
which corresponds $\renameAlphabet$ (it issues an error message and
raises an exception if its second argument isn't legal).
This function is also inherited by the modules \texttt{DFA},
\texttt{NFA} and \texttt{EFA}.
\index{NFA@\texttt{NFA}!renameAlphabet@\texttt{renameAlphabet}}%
\index{DFA@\texttt{DFA}!renameAlphabet@\texttt{renameAlphabet}}%
Here is an example of how one of these functions can be used:
\input{chap-3.12-forlan15}

\subsection{Notes}

The material in this section is mostly standard, but is worked-out in
more detail than is common.  We have given an intersection algorithm
on EFAs, not just on DFAs.  By giving a complementation algorithm on
DFAs that allows us to partially control the alphabet of the resulting
DFA, we are able to give an algorithm for computing the difference of
DFAs that works even when the DFAs have different alphabets.

\index{regular languages!closure properties|)}%

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "book"
%%% End: 
