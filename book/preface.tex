\chapter*{Preface}
\chaptermark{Preface}

\section*{Background}
\label{Background}

Since the 1930s, the subject of formal language theory, also known as
automata theory, has been developed by computer scientists, linguists
and mathematicians.  Formal languages (or simply languages) are sets
of strings over finite sets of symbols, called alphabets, and various
ways of describing such languages have been developed and studied,
including regular expressions (which ``generate'' languages), finite
automata (which ``accept'' languages), grammars (which ``generate''
languages) and Turing machines (which ``accept'' languages).  For
example, the set of identifiers of a given programming language is a
formal language---one that can be described by a regular expression or
a finite automaton.  And, the set of all strings of tokens that are
generated by a programming language's grammar is another example of a
formal language.

Because of its applications to computer science, most computer science
programs offer courses in this subject.  Perhaps the best known
applications are to compiler construction.  For example, regular
expressions and finite automata are used when specifying and
implementing lexical analyzers, and grammars are used to specify and
implement parsers.  Finite automata are used when designing hardware
and network protocols.  And Turing machines---or other
machines/programs of equivalent power---are used to formalize the
notion of algorithm, which in turn makes possible the study of what
is, and is not, computable.

Formal language theory is largely concerned with algorithms, both ones
that are explicitly presented, and ones implicit in theorems that are
proved constructively.  In typical courses on formal language theory,
students apply these algorithms to toy examples by hand, and learn how
they are used in applications.  Although much can be achieved by a
paper-and-pencil approach to the subject, students would obtain a
deeper understanding of the subject if they could experiment with the
algorithms of formal language theory using computer tools.

Consider, e.g., a typical exercise of a formal language theory class
in which students are asked to synthesize a deterministic finite
automaton that accepts some language, $L$.  With the paper-and-pencil
approach, the student is obliged to build the machine by hand, and
then (hopefully) prove it correct.  But, given the right
computer tools, another approach would be possible.  First, the
student could try to express $L$ in terms of simpler languages, making
use of various language operations (e.g., union, intersection,
difference, concatenation, closure).  The student could then
synthesize automata accepting the simpler languages, enter these
machines into the system, and then combine these machines using
operations corresponding to the language operations used to express
$L$.  Finally, the resulting machine could be minimized.  With some
such exercises, a student could solve the exercise in both ways, and
could compare the results.  Other exercises of this type could only be
solved with machine support.

\section*{Integrating Experimentation and Proof}
\label{IntegratingExperimentationAndProof}

To support experimentation with formal languages, I designed and
implemented a computer toolset called Forlan \cite{Stoughton05,
  Stoughton08}.  Forlan is implemented in the functional programming
language Standard ML (SML) \cite{Milner97, Paulson96}, a language
whose notation and concepts are similar to those of mathematics.
Forlan is a library on top of the Standard ML of New Jersey
(SML/NJ) implementation of SML \cite{AppelMacQueen91}.  It's used
interactively, and users are able to extend Forlan by defining SML
functions.

In Forlan, the usual objects of formal language theory---finite
automata, regular expressions, grammars, labeled paths, parse trees,
etc.---are defined as abstract types, and have concrete syntax.
Instead of Turing machines, Forlan implements a simple functional
programming language of equivalent power, but which has the advantage
of being much easier to program in than Turing machines.  Programs are
also abstract types, and have concrete syntax.  Although mainly
\emph{not} graphical in nature, Forlan includes the Java program
JForlan,
\index{JForlan}%
a graphical editor for finite automata and regular expression, parse
and program trees.  It can be invoked directly, or via Forlan.

Numerous algorithms of formal language theory are implemented in
Forlan, including conversions between regular expressions and
different kinds of automata, the usual operations (e.g., union) on
regular expressions, automata and grammars, equivalence testing and
minimization of deterministic finite automata, a general parser for
grammars, etc.  Forlan provides support for regular expression
simplification, although the algorithms used are works in progress.
It also implements the functional programming language used as a
substitute for Turing machines.

This textbook and Forlan were designed and developed together.  I have
attempted to keep the conceptual and notational distance between the
textbook and toolset as small as possible.  The book treats most
concepts and algorithms both theoretically, especially using proof,
and through experimentation, using Forlan.

In contrast to some books on formal language theory, the book
emphasizes the concrete over the abstract, providing numerous, fully
worked-out examples of how regular expressions, finite automata,
grammars and programs can be designed and proved correct.  In my view,
students are most able to learn how to write proofs---and to see the
benefit of doing so---if their proofs are about things that they have
designed.

I have also attempted to simplify the foundations of the subject,
using alternative definitions when needed. E.g., finite automata are
defined in such a way that they form a set (as opposed to a proper
class), and so that more restricted forms of automata (e.g.,
deterministic finite automata (DFAs)) are proper subsets of that
set. And finite automata are given semantics using labeled paths, from
which the traditional $\delta$ notation is derived, in the case of
DFAs. Furthermore, the book treats the set theoretic foundations of
the subject more rigorously than is typical, covering topics
like inductive definitions and well-founded relations, induction
and recursion.

Readers of this book are assumed to have significant experience
reading and writing informal mathematical proofs, of the kind one
finds in mathematics books.  This experience could have been gained,
e.g., in courses on discrete mathematics, logic or set theory.  The
book assumes no previous knowledge of Standard ML.  In order to
understand and extend the implementation of Forlan, though, one must
have a good working knowledge of Standard ML, as could be obtained by
working through \cite{Paulson96} or \cite{Ullman98}.

Drafts of this book have been successfully used: at Kansas State
University in a semester long, advanced undergraduate-level course;
and at Boston University in a semester-long
advanced-undergraduate/beginning graduate-level course.

\section*{Outline of the Book}
\label{OutlineOfTheBook}

The book consists of five chapters.
Chapter~\ref{MathematicalBackground}, \emph{Mathematical Background},
consists of the material on set theory, induction and recursion, and
trees and inductive definitions that is required in the remaining
chapters.

In Chapter~\ref{FormalLanguages}, \emph{Formal Languages},
we say what symbols, strings, alphabets and (formal) languages are,
show how to use various induction principles to prove language
equalities, and give an introduction to the Forlan toolset.  The
remaining three chapters introduce and study more restricted sets of
languages.

In Chapter~\ref{RegularLanguages}, \emph{Regular Languages}, we study
regular expressions and languages, five kinds of finite automata,
algorithms for processing and converting between regular expressions
and finite automata, properties of regular languages, and applications
of regular expressions and finite automata to searching in text files,
lexical analysis, and the design of finite state systems.

In Chapter~\ref{ContextFreeLanguages}, \emph{Context-free Languages},
we study context-free grammars and languages, algorithms for
processing grammars and for converting regular expressions and finite
automata to grammars, top-down (recursive descent) parsing, and
properties of context-free languages.  We prove that the set of context-free
languages is a proper superset of the set of regular languages.

Finally, in Chapter~\ref{RecursiveAndRecursivelyEnumerableLanguages},
\emph{Recursive and Recursively Enumerable Languages}, we study the
functional programming language that we use instead of Turing machines
to define the recursive and recursively enumerable languages.  We
study algorithms for processing programs and for converting grammars
to programs, and properties of recursive and recursively enumerable
languages.  We prove that the set of context-free languages is a
proper subset of the set of recursive languages, that the set of
recursive languages is a proper subset of the set of recursively
enumerable languages, and that there are languages that are not
recursively enumerable.  Furthermore, we show that there are problems,
like the halting problem (the problem of determining whether a program
halts when run on a given input), that can't be solved by programs.

\section*{Further Reading and Related Work}
\label{FurtherReadingAndRelatedWork}

This book covers most of the material that is typically presented in
an undergraduate course on formal language theory.  On the other hand,
typical textbooks on formal language theory cover much more of the
subject than we do.  Readers who are interested in learning more, or
who would like to be exposed to alternative presentations of some of
the material in this book, should consult one of the many fine books
on formal language theory, such as
\cite{HopcroftMotwaniUllman01,Kozen97,LewisPapadimitriou98,Martin91,Linz01}.

Neil Jones \cite{Jones97} pioneered the use of a programming language
with structured data as an alternative to Turing machines for studying
the limits of what is computable.  In
Chapter~\ref{RecursiveAndRecursivelyEnumerableLanguages}, we have
followed Jones's approach in some ways.  On the other hand, our
programming language is functional, not imperative
(assignment-oriented), and it has explicit support for the symbols and
strings of formal language theory.

The existing formal languages toolsets fit into two categories.  In the
first category are tools, like JFLAP \cite{Rodger97,Rodger00,Rodger06},
\Pate\ \cite{Rodger97,Rodger00}, the Java Computability Toolkit
\cite{Robinson99}, and Turing's World \cite{BarwiseEtchemendy93}, that
are graphically oriented and help students work out relatively small
examples.  The books \cite{Rodger06} (on JFLAP) and \cite{Linz01} (an
introduction to formal language theory) are intended to be used in
conjunction with each other.  The second category consists of toolsets
that, like Forlan, are embedded in programming languages, and so
support sophisticated experimentation with formal languages.  Toolsets
in this category include Automata \cite{Sutner92}, Grail+
\cite{Raymond94,Grail}, HaLeX \cite{Saraiva02}, Lei\ss's Automata
Library \cite{Leiss} and Vaucanson \cite{Lombardy04}.  I am not
aware of other textbook/toolset packages whose toolsets are
members of this second category.

\section*{Notes, Exercises and Website}
\label{NotesAndExercisesAndWebsite}

In the ``notes'' subsections that conclude most sections of the book,
I have restricted myself to describing how the book's approach differs
from standard practice.  Readers interested in the history of the
subject can consult
\cite{HopcroftMotwaniUllman01,Kozen97,LewisPapadimitriou98}.

The book contains numerous fully worked-out examples, many of which
consist of designing and proving the correctness of regular
expressions, finite automata, grammars and programs.  Similar
exercises, as well as other kinds of exercises, are scattered
throughout the book.

The Forlan website
\begin{center}
\url{http://alleystoughton.us/forlan}
\end{center}
contains:
\begin{itemize}
\item instructions for downloading and installing the Forlan toolset,
  and JForlan;

\item the Forlan manual;

\item instructions for reporting errors or making suggestions; and

\item the Forlan distribution, including the source for Forlan and
  JForlan, as well as the \LaTeX\ source for this book.
\end{itemize}

\section*{Acknowledgments}
\label{Acknowledgments}

Leonard Lee and Jessica Sherrill designed and implemented graphical
editors for Forlan finite automata (JFA), and regular expression and
parse trees (JTR), respectively.  Their work was unified and enhanced
(of particular note was the addition of support for program trees) by
Srinivasa Aditya Uppu, resulting in an initial version of JForlan.
\index{JForlan}%
Subsequently, Kenton Born carried out a major redevelopment of
JForlan, resulting in JForlan Version 1.0. A further revision, by the
author, led to JForlan Version 2.0.

It is a pleasure to acknowledge helpful discussions relating to the
Forlan project with Eli Fox-Epstein, Brian Howard, Rod Howell, John
Hughes, Nathan James, Patrik Jansson, Jace Kohlmeier, Dexter Kozen,
Matthew Miller, Aarne Ranta, Ryan Stejskal, Colin Stirling, Lucio
Torrico and Lyn Turbak.  Much of this work was done while I was
employed by Kansas State University, and some of the work was done
while I was on sabbatical at the Department of Computing Science of
Chalmers University of Technology.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "book"
%%% End: 
