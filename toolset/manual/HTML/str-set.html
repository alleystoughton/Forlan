<!-- HTML/str-set.html -->

<!-- COPYRIGHT (c) 2018 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The StrSet Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>StrSet</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="STR_SET:SIG:SPEC"></A><CODE>STR_SET</CODE><BR>
<B>structure</B>&nbsp;<A NAME="StrSet:STR:SPEC"></A><CODE>StrSet</CODE><B> :> </B>STR_SET<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module provides operations on finite sets of Forlan strings, i.e., values of type <CODE><CODE><A HREF="str.html#Str:STR:SPEC">Str</A></CODE>.<CODE><A HREF="str.html#SIG:STR.str:TY:SPEC">str</A></CODE>
<CODE><A HREF="set.html#Set:STR:SPEC">Set</A></CODE>.<CODE><A HREF="set.html#SIG:SET.set:TY:SPEC">set</A></CODE></CODE> that are <EM>standard</EM> in the sense that they are compatible with <CODE><A HREF="str.html#Str:STR:SPEC">Str</A></CODE>.<CODE><A HREF="str.html#SIG:STR.compare:VAL:SPEC">compare</A></CODE>.  All values of type <CODE>Str.str Set.set</CODE> will implicitly be assumed/required to be standard.
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>val</B>&nbsp;<A NAME="STR:StrSet.memb:VAL:SPEC" HREF="#STR:StrSet.memb:VAL">memb</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.fromList:VAL:SPEC" HREF="#STR:StrSet.fromList:VAL">fromList</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.compare:VAL:SPEC" HREF="#STR:StrSet.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.subset:VAL:SPEC" HREF="#STR:StrSet.subset:VAL">subset</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.equal:VAL:SPEC" HREF="#STR:StrSet.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.map:VAL:SPEC" HREF="#STR:StrSet.map:VAL">map</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;Str.str)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.mapFromList:VAL:SPEC" HREF="#STR:StrSet.mapFromList:VAL">mapFromList</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;Str.str)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.union:VAL:SPEC" HREF="#STR:StrSet.union:VAL">union</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.genUnion:VAL:SPEC" HREF="#STR:StrSet.genUnion:VAL">genUnion</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.inter:VAL:SPEC" HREF="#STR:StrSet.inter:VAL">inter</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.genInter:VAL:SPEC" HREF="#STR:StrSet.genInter:VAL">genInter</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.minus:VAL:SPEC" HREF="#STR:StrSet.minus:VAL">minus</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.inputFromLabToks:VAL:SPEC" HREF="#STR:StrSet.inputFromLabToks:VAL">inputFromLabToks</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.fromString:VAL:SPEC" HREF="#STR:StrSet.fromString:VAL">fromString</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.input:VAL:SPEC" HREF="#STR:StrSet.input:VAL">input</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.toPP:VAL:SPEC" HREF="#STR:StrSet.toPP:VAL">toPP</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;PP.pp<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.toString:VAL:SPEC" HREF="#STR:StrSet.toString:VAL">toString</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;string<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.output:VAL:SPEC" HREF="#STR:StrSet.output:VAL">output</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.concat:VAL:SPEC" HREF="#STR:StrSet.concat:VAL">concat</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.power:VAL:SPEC" HREF="#STR:StrSet.power:VAL">power</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;int&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.rev:VAL:SPEC" HREF="#STR:StrSet.rev:VAL">rev</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.prefixes:VAL:SPEC" HREF="#STR:StrSet.prefixes:VAL">prefixes</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.prefix:VAL:SPEC" HREF="#STR:StrSet.prefix:VAL">prefix</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.suffix:VAL:SPEC" HREF="#STR:StrSet.suffix:VAL">suffix</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.substring:VAL:SPEC" HREF="#STR:StrSet.substring:VAL">substring</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.alphabet:VAL:SPEC" HREF="#STR:StrSet.alphabet:VAL">alphabet</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:StrSet.renameAlphabet:VAL:SPEC" HREF="#STR:StrSet.renameAlphabet:VAL">renameAlphabet</A>&nbsp;<B>:</B>&nbsp;Str.str&nbsp;Set.set&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;Set.set</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:StrSet.memb:VAL"></A>
<DT> <CODE>memb(<VAR>x</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> is a member of <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.fromList:VAL"></A>
<DT> <CODE>fromList <VAR>xs</VAR></CODE>
<DD>
returns the set whose elements are the elements of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.compare:VAL"></A>
<DT> <CODE>compare</CODE>
<DD>
is <CODE><CODE><A HREF="set.html#Set:STR:SPEC">Set</A></CODE>.<CODE><A HREF="set.html#SIG:SET.compare:VAL:SPEC">compare</A></CODE>
<CODE><A HREF="str.html#Str:STR:SPEC">Str</A></CODE>.<CODE><A HREF="str.html#SIG:STR.compare:VAL:SPEC">compare</A></CODE></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.subset:VAL"></A>
<DT> <CODE>subset(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>xs</VAR></CODE> is a subset of <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.equal:VAL"></A>
<DT> <CODE>equal(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>xs</VAR></CODE> is equal to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.map:VAL"></A>
<DT> <CODE>map <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>map</CODE> returns the set of all Forlan strings <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> such that <CODE><VAR>x</VAR></CODE> is a member of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.mapFromList:VAL"></A>
<DT> <CODE>mapFromList <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
returns the set of all Forlan strings <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> such that <CODE><VAR>x</VAR></CODE> is a member of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.union:VAL"></A>
<DT> <CODE>union(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
returns the union of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.genUnion:VAL"></A>
<DT> <CODE>genUnion <VAR>xss</VAR></CODE>
<DD>
returns the generalized union of <CODE><VAR>xss</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.inter:VAL"></A>
<DT> <CODE>inter(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
returns the intersection of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.genInter:VAL"></A>
<DT> <CODE>genInter <VAR>xss</VAR></CODE>
<DD>
returns the generalized intersection of <CODE><VAR>xss</VAR></CODE>.  Issues an error message if <CODE><VAR>xss</VAR></CODE> is empty.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.minus:VAL"></A>
<DT> <CODE>minus(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
returns the difference of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.inputFromLabToks:VAL"></A>
<DT> <CODE>inputFromLabToks <VAR>lts</VAR></CODE>
<DD>
tries to input a set of Forlan strings from <CODE><VAR>lts</VAR></CODE>, consuming as much of <CODE><VAR>lts</VAR></CODE> as possible, and returning the pair of the set of strings and the rest of <CODE><VAR>lts</VAR></CODE>.  Issues an error message if it fails. Will only return the empty set if <CODE><VAR>lts</VAR></CODE> doesn't begin with a symbol or <CODE>&quot;%&quot;</CODE> (<CODE><CODE><A HREF="lex.html#Lex:STR:SPEC">Lex</A></CODE>.<CODE><A HREF="lex.html#SIG:LEX.tok:TY:SPEC">Perc</A></CODE></CODE>).If, after reading a string, the next element of the labeled token list is <CODE>&quot;,&quot;</CODE> (<CODE>Lex.Comma</CODE>), then <CODE>inputFromLabToks</CODE> insists on reading another string, even if this results in failure.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.fromString:VAL"></A>
<DT> <CODE>fromString <VAR>s</VAR></CODE>
<DD>
inputs a set of string from <CODE><VAR>s</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.input:VAL"></A>
<DT> <CODE>input <VAR>fil</VAR></CODE>
<DD>
inputs a set of strings from the file <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.toPP:VAL"></A>
<DT> <CODE>toPP <VAR>xs</VAR></CODE>
<DD>
returns a pretty-printing expression for <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.toString:VAL"></A>
<DT> <CODE>toString <VAR>xs</VAR></CODE>
<DD>
pretty-prints <CODE><VAR>xs</VAR></CODE> to a string.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.output:VAL"></A>
<DT> <CODE>output(<VAR>fil</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
pretty-prints <CODE><VAR>xs</VAR></CODE> to file <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.concat:VAL"></A>
<DT> <CODE>concat(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
returns the concatentation of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.power:VAL"></A>
<DT> <CODE>power(<VAR>xs</VAR>, <VAR>n</VAR>)</CODE>
<DD>
raises <CODE><VAR>xs</VAR></CODE> to the power <CODE><VAR>n</VAR></CODE>.  Issues an error message if <CODE><VAR>n</VAR></CODE> is negative.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.rev:VAL"></A>
<DT> <CODE>rev <VAR>xs</VAR></CODE>
<DD>
returns the reversal of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.prefixes:VAL"></A>
<DT> <CODE>prefixes <VAR>x</VAR></CODE>
<DD>
returns the set of all prefixes of <CODE><VAR>x</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.prefix:VAL"></A>
<DT> <CODE>prefix <VAR>xs</VAR></CODE>
<DD>
returns the prefix closure of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.suffix:VAL"></A>
<DT> <CODE>suffix <VAR>xs</VAR></CODE>
<DD>
returns the suffix closure of <CODE><VAR>xs</VAR></CODE>. It is defined by 
<PRE>
  fun suffix xs = rev(prefix(rev xs))
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:StrSet.substring:VAL"></A>
<DT> <CODE>substring <VAR>xs</VAR></CODE>
<DD>
returns the substring closure of <CODE><VAR>xs</VAR></CODE>.  It is defined by 
<PRE>
  fun substring xs = suffix(prefix xs)
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:StrSet.alphabet:VAL"></A>
<DT> <CODE>alphabet <VAR>xs</VAR></CODE>
<DD>
returns the alphabet of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:StrSet.renameAlphabet:VAL"></A>
<DT> <CODE>renameAlphabet <VAR>xs</VAR></CODE>
<DD>
renames the alphabet of <CODE><VAR>xs</VAR></CODE> using the bijection <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> is not a bijection from a superset of the alphabet of <CODE><VAR>xs</VAR></CODE> to some set.
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="sym-str-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.10</I><BR>
<I>Copyright &copy; 2018 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
