<!-- HTML/sym-rel.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The SymRel Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>SymRel</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="SYM_REL:SIG:SPEC"></A><CODE>SYM_REL</CODE><BR>
<B>structure</B>&nbsp;<A NAME="SymRel:STR:SPEC"></A><CODE>SymRel</CODE><B> :> </B>SYM_REL<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module provides operations on finite relations on Forlan symbols, i.e., values of type <CODE><CODE><A HREF="sym-rel.html#SIG:SYM_REL.sym_rel:TY:SPEC">sym_rel</A></CODE> = (<CODE><A HREF="sym.html#Sym:STR:SPEC">Sym</A></CODE>.<CODE><A HREF="sym.html#SIG:SYM.sym:TY:SPEC">sym</A></CODE>,
<CODE><A HREF="sym.html#Sym:STR:SPEC">Sym</A></CODE>.<CODE><A HREF="sym.html#SIG:SYM.sym:TY:SPEC">sym</A></CODE>)<CODE><A HREF="rel.html#Rel:STR:SPEC">Rel</A></CODE>.<CODE><A HREF="rel.html#SIG:REL.rel:TY:SPEC">rel</A></CODE></CODE> that are <EM>standard</EM> in the sense that they are compatible with <CODE><CODE><A HREF="set.html#Set:STR:SPEC">Set</A></CODE>.<CODE><A HREF="set.html#SIG:SET.comparePair:VAL:SPEC">comparePair</A></CODE>(<CODE><A HREF="sym.html#Sym:STR:SPEC">Sym</A></CODE>.<CODE><A HREF="sym.html#SIG:SYM.compare:VAL:SPEC">compare</A></CODE>,
<CODE><A HREF="sym.html#Sym:STR:SPEC">Sym</A></CODE>.<CODE><A HREF="sym.html#SIG:SYM.compare:VAL:SPEC">compare</A></CODE>)</CODE>. All values of type <CODE>sym_rel</CODE> will implicitly be assumed/required to be standard.
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<A NAME="STR:SymRel.sym_rel:TY:SPEC" HREF="#STR:SymRel.sym_rel:TY">sym_rel</A>&nbsp;=&nbsp;(Sym.sym,&nbsp;Sym.sym)&nbsp;Rel.rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.comparePair:VAL:SPEC" HREF="#STR:SymRel.comparePair:VAL">comparePair</A>&nbsp;<B>:</B>&nbsp;(Sym.sym&nbsp;<B>*</B>&nbsp;Sym.sym)&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.memb:VAL:SPEC" HREF="#STR:SymRel.memb:VAL">memb</A>&nbsp;<B>:</B>&nbsp;(Sym.sym&nbsp;<B>*</B>&nbsp;Sym.sym)&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.fromList:VAL:SPEC" HREF="#STR:SymRel.fromList:VAL">fromList</A>&nbsp;<B>:</B>&nbsp;(Sym.sym&nbsp;<B>*</B>&nbsp;Sym.sym)&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.compare:VAL:SPEC" HREF="#STR:SymRel.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.subset:VAL:SPEC" HREF="#STR:SymRel.subset:VAL">subset</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.equal:VAL:SPEC" HREF="#STR:SymRel.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.map:VAL:SPEC" HREF="#STR:SymRel.map:VAL">map</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Sym.sym)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.mapFromList:VAL:SPEC" HREF="#STR:SymRel.mapFromList:VAL">mapFromList</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Sym.sym)&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.union:VAL:SPEC" HREF="#STR:SymRel.union:VAL">union</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.genUnion:VAL:SPEC" HREF="#STR:SymRel.genUnion:VAL">genUnion</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.inter:VAL:SPEC" HREF="#STR:SymRel.inter:VAL">inter</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.genInter:VAL:SPEC" HREF="#STR:SymRel.genInter:VAL">genInter</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.minus:VAL:SPEC" HREF="#STR:SymRel.minus:VAL">minus</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.domain:VAL:SPEC" HREF="#STR:SymRel.domain:VAL">domain</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.range:VAL:SPEC" HREF="#STR:SymRel.range:VAL">range</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.relationFromTo:VAL:SPEC" HREF="#STR:SymRel.relationFromTo:VAL">relationFromTo</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.relationOn:VAL:SPEC" HREF="#STR:SymRel.relationOn:VAL">relationOn</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.apply:VAL:SPEC" HREF="#STR:SymRel.apply:VAL">apply</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.reflexive:VAL:SPEC" HREF="#STR:SymRel.reflexive:VAL">reflexive</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.symmetric:VAL:SPEC" HREF="#STR:SymRel.symmetric:VAL">symmetric</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.antisymmetric:VAL:SPEC" HREF="#STR:SymRel.antisymmetric:VAL">antisymmetric</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.transitive:VAL:SPEC" HREF="#STR:SymRel.transitive:VAL">transitive</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.total:VAL:SPEC" HREF="#STR:SymRel.total:VAL">total</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.inverse:VAL:SPEC" HREF="#STR:SymRel.inverse:VAL">inverse</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.reflexiveClosure:VAL:SPEC" HREF="#STR:SymRel.reflexiveClosure:VAL">reflexiveClosure</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.transitiveClosure:VAL:SPEC" HREF="#STR:SymRel.transitiveClosure:VAL">transitiveClosure</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.reflexiveTransitiveClosure:VAL:SPEC" HREF="#STR:SymRel.reflexiveTransitiveClosure:VAL">reflexiveTransitiveClosure</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.symmetricClosure:VAL:SPEC" HREF="#STR:SymRel.symmetricClosure:VAL">symmetricClosure</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.transitiveSymmetricClosure:VAL:SPEC" HREF="#STR:SymRel.transitiveSymmetricClosure:VAL">transitiveSymmetricClosure</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.reflexiveTransitiveSymmetricClosure:VAL:SPEC" HREF="#STR:SymRel.reflexiveTransitiveSymmetricClosure:VAL">reflexiveTransitiveSymmetricClosure</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.compose:VAL:SPEC" HREF="#STR:SymRel.compose:VAL">compose</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.function:VAL:SPEC" HREF="#STR:SymRel.function:VAL">function</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.functionFromTo:VAL:SPEC" HREF="#STR:SymRel.functionFromTo:VAL">functionFromTo</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.injection:VAL:SPEC" HREF="#STR:SymRel.injection:VAL">injection</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.bijectionFromTo:VAL:SPEC" HREF="#STR:SymRel.bijectionFromTo:VAL">bijectionFromTo</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.bijectionFromAvoiding:VAL:SPEC" HREF="#STR:SymRel.bijectionFromAvoiding:VAL">bijectionFromAvoiding</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.bijectionFromSupersetAvoiding:VAL:SPEC" HREF="#STR:SymRel.bijectionFromSupersetAvoiding:VAL">bijectionFromSupersetAvoiding</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.applyFunction:VAL:SPEC" HREF="#STR:SymRel.applyFunction:VAL">applyFunction</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;<B>-&gt;</B>&nbsp;Sym.sym<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.restrictFunction:VAL:SPEC" HREF="#STR:SymRel.restrictFunction:VAL">restrictFunction</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.updateFunction:VAL:SPEC" HREF="#STR:SymRel.updateFunction:VAL">updateFunction</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.mlFunctionToFunction:VAL:SPEC" HREF="#STR:SymRel.mlFunctionToFunction:VAL">mlFunctionToFunction</A>&nbsp;<B>:</B>&nbsp;(Sym.sym&nbsp;<B>-&gt;</B>&nbsp;Sym.sym)&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.inputFromLabToks:VAL:SPEC" HREF="#STR:SymRel.inputFromLabToks:VAL">inputFromLabToks</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;sym_rel&nbsp;<B>*</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.fromString:VAL:SPEC" HREF="#STR:SymRel.fromString:VAL">fromString</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.input:VAL:SPEC" HREF="#STR:SymRel.input:VAL">input</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.toPP:VAL:SPEC" HREF="#STR:SymRel.toPP:VAL">toPP</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;PP.pp<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.toString:VAL:SPEC" HREF="#STR:SymRel.toString:VAL">toString</A>&nbsp;<B>:</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;string<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.output:VAL:SPEC" HREF="#STR:SymRel.output:VAL">output</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>*</B>&nbsp;sym_rel&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:SymRel.makeBijectionFromAvoiding:VAL:SPEC" HREF="#STR:SymRel.makeBijectionFromAvoiding:VAL">makeBijectionFromAvoiding</A>&nbsp;<B>:</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;sym_rel</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:SymRel.sym_rel:TY"></A><CODE><B>type</B>&nbsp;sym_rel&nbsp;=&nbsp;(Sym.sym,&nbsp;Sym.sym)&nbsp;Rel.rel</CODE>
<DD>
The type of finite relations on Forlan symbols.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.comparePair:VAL"></A>
<DT> <CODE>comparePair</CODE>
<DD>
is  <CODE><CODE><A HREF="set.html#Set:STR:SPEC">Set</A></CODE>.<CODE><A HREF="set.html#SIG:SET.comparePair:VAL:SPEC">comparePair</A></CODE>(<CODE><A HREF="sym.html#Sym:STR:SPEC">Sym</A></CODE>.<CODE><A HREF="sym.html#SIG:SYM.compare:VAL:SPEC">compare</A></CODE>,
<CODE><A HREF="sym.html#Sym:STR:SPEC">Sym</A></CODE>.<CODE><A HREF="sym.html#SIG:SYM.compare:VAL:SPEC">compare</A></CODE>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.memb:VAL"></A>
<DT> <CODE>memb((<VAR>a</VAR>, <VAR>b</VAR>), <VAR>rel</VAR>)</CODE>
<DD>
tests whether <CODE>(<VAR>a</VAR>, <VAR>b</VAR>)</CODE> is a member of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.fromList:VAL"></A>
<DT> <CODE>fromList <VAR>xs</VAR></CODE>
<DD>
returns a relation whose members are the pairs in <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.compare:VAL"></A>
<DT> <CODE>compare</CODE>
<DD>
is <CODE><CODE><A HREF="set.html#Set:STR:SPEC">Set</A></CODE>.<CODE><A HREF="set.html#SIG:SET.compare:VAL:SPEC">compare</A></CODE> comparePair</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.subset:VAL"></A>
<DT> <CODE>subset(<VAR>rel1</VAR>, <VAR>rel2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel1</VAR></CODE> is a subset of <CODE><VAR>rel2</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.equal:VAL"></A>
<DT> <CODE>equal(<VAR>rel1</VAR>, <VAR>rel2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel1</VAR></CODE> and <CODE><VAR>rel2</VAR></CODE> are equal.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.map:VAL"></A>
<DT> <CODE>map <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>map</CODE> returns the set of all pairs of symbols <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> such that <CODE><VAR>x</VAR></CODE> is a member of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.mapFromList:VAL"></A>
<DT> <CODE>mapFromList <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
returns the set of all pairs of symbols <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> such that <CODE><VAR>x</VAR></CODE> is a member of <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.union:VAL"></A>
<DT> <CODE>union(<VAR>rel1</VAR>, <VAR>rel2</VAR>)</CODE>
<DD>
returns the union of <CODE><VAR>rel1</VAR></CODE> and <CODE><VAR>rel2</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.genUnion:VAL"></A>
<DT> <CODE>genUnion <VAR>rels</VAR></CODE>
<DD>
returns the generalized union of <CODE><VAR>rels</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.inter:VAL"></A>
<DT> <CODE>inter(<VAR>rel1</VAR>, <VAR>rel2</VAR>)</CODE>
<DD>
returns the intersection of <CODE><VAR>rel1</VAR></CODE> and <CODE><VAR>rel2</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.genInter:VAL"></A>
<DT> <CODE>genInter <VAR>rels</VAR></CODE>
<DD>
returns the generalized intersection of <CODE><VAR>rels</VAR></CODE>. Issues an error message if <CODE><VAR>rels</VAR></CODE> is empty.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.minus:VAL"></A>
<DT> <CODE>minus(<VAR>rel1</VAR>, <VAR>rel2</VAR>)</CODE>
<DD>
returns the difference of <CODE><VAR>rel1</VAR></CODE> and <CODE><VAR>rel2</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.domain:VAL"></A>
<DT> <CODE>domain <VAR>rel</VAR></CODE>
<DD>
returns the domain of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.range:VAL"></A>
<DT> <CODE>range <VAR>rel</VAR></CODE>
<DD>
returns the range of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.relationFromTo:VAL"></A>
<DT> <CODE>relationFromTo(<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a relation from <CODE><VAR>xs</VAR></CODE> to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.relationOn:VAL"></A>
<DT> <CODE>relationOn(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a relation on <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.apply:VAL"></A>
<DT> <CODE>apply(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
returns the set of all symbols <CODE><VAR>y</VAR></CODE> such that there is a symbol <CODE><VAR>x</VAR></CODE> in <CODE><VAR>xs</VAR></CODE> such that <CODE>(<VAR>x</VAR>, <VAR>y</VAR>)</CODE> is a member of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.reflexive:VAL"></A>
<DT> <CODE>reflexive(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is reflexive on <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.symmetric:VAL"></A>
<DT> <CODE>symmetric <VAR>rel</VAR></CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is symmetric.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.antisymmetric:VAL"></A>
<DT> <CODE>antisymmetric <VAR>rel</VAR></CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is antisymmetric.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.transitive:VAL"></A>
<DT> <CODE>transitive <VAR>rel</VAR></CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is transitive.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.total:VAL"></A>
<DT> <CODE>total(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is total on <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.inverse:VAL"></A>
<DT> <CODE>inverse <VAR>rel</VAR></CODE>
<DD>
returns the inverse of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.reflexiveClosure:VAL"></A>
<DT> <CODE>reflexiveClosure(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
returns the reflexive closure of <CODE><VAR>rel</VAR></CODE> with respect to <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.transitiveClosure:VAL"></A>
<DT> <CODE>transitiveClosure <VAR>rel</VAR></CODE>
<DD>
returns the transitive closure of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.reflexiveTransitiveClosure:VAL"></A>
<DT> <CODE>reflexiveTransitiveClosure(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
returns the reflexive, transitive closure of <CODE><VAR>rel</VAR></CODE> with respect to <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.symmetricClosure:VAL"></A>
<DT> <CODE>symmetricClosure <VAR>rel</VAR></CODE>
<DD>
returns the symmetric closure of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.transitiveSymmetricClosure:VAL"></A>
<DT> <CODE>transitiveSymmetricClosure <VAR>rel</VAR></CODE>
<DD>
returns the transitive, symmetric closure of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.reflexiveTransitiveSymmetricClosure:VAL"></A>
<DT> <CODE>reflexiveTransitiveSymmetricClosure(<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
returns the reflexive, transitive, symmetric closure of <CODE><VAR>rel</VAR></CODE> with respect to <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.compose:VAL"></A>
<DT> <CODE>compose(<VAR>rel2</VAR>, <VAR>rel1</VAR>)</CODE>
<DD>
returns the composition of <CODE><VAR>rel2</VAR></CODE> and <CODE><VAR>rel1</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.function:VAL"></A>
<DT> <CODE>function <VAR>rel</VAR></CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a function.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.functionFromTo:VAL"></A>
<DT> <CODE>functionFromTo(<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a function from <CODE><VAR>xs</VAR></CODE> to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.injection:VAL"></A>
<DT> <CODE>injection <VAR>rel</VAR></CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is an injection.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.bijectionFromTo:VAL"></A>
<DT> <CODE>bijectionFromTo(<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a bijection from <CODE><VAR>xs</VAR></CODE> to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.bijectionFromAvoiding:VAL"></A>
<DT> <CODE>bijectionFromAvoiding(<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a bijection from <CODE><VAR>xs</VAR></CODE> to a set that is disjoint from <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.bijectionFromSupersetAvoiding:VAL"></A>
<DT> <CODE>bijectionFromSupersetAvoiding(<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is a bijection from a superset of <CODE><VAR>xs</VAR></CODE> to a set that is disjoint from <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.applyFunction:VAL"></A>
<DT> <CODE>applyFunction(<VAR>rel</VAR>, <VAR>a</VAR>)</CODE>
<DD>
applies the function <CODE><VAR>rel</VAR></CODE> to <CODE><VAR>a</VAR></CODE>. It issues an error message if <CODE><VAR>rel</VAR></CODE> is not a function, or if <CODE><VAR>a</VAR></CODE> is not in the domain of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.restrictFunction:VAL"></A>
<DT> <CODE>restrictFunction(<VAR>rel</VAR>, <VAR>bs</VAR>)</CODE>
<DD>
returns the function that is the restriction of <CODE><VAR>rel</VAR></CODE> to <CODE><VAR>bs</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> isn't a function, or if <CODE><VAR>bs</VAR></CODE> isn't a subset of the domain of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.updateFunction:VAL"></A>
<DT> <CODE>updateFunction(<VAR>rel</VAR>, <VAR>b</VAR>, <VAR>c</VAR>)</CODE>
<DD>
returns the function that is the updating of the function <CODE><VAR>rel</VAR></CODE> to send <CODE><VAR>b</VAR></CODE> to <CODE><VAR>c</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> isn't a function.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.mlFunctionToFunction:VAL"></A>
<DT> <CODE>mlFunctionToFunction(<VAR>f</VAR>, <VAR>bs</VAR>)</CODE>
<DD>
returns the function <CODE><VAR>rel</VAR></CODE> whose domain is <CODE><VAR>bs</VAR></CODE>, and where, for all elements <CODE><VAR>b</VAR></CODE> of <CODE><VAR>bs</VAR></CODE>, <CODE>(<VAR>b</VAR>,
<VAR>f</VAR> <VAR>b</VAR>)</CODE> is a member of <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>f</VAR></CODE> raises an exception when called on one or more elements of <CODE><VAR>bs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.inputFromLabToks:VAL"></A>
<DT> <CODE>inputFromLabToks <VAR>lts</VAR></CODE>
<DD>
tries to input a relation from <CODE><VAR>lts</VAR></CODE>, consuming as much of <CODE><VAR>lts</VAR></CODE> as possible, and returning the pair of the relation and the rest of <CODE><VAR>lts</VAR></CODE>. Issues an error message if it fails. Will only return the empty relation if <CODE><VAR>lts</VAR></CODE> doesn't begin with a <CODE>&quot;(&quot;</CODE> (<CODE><CODE><A HREF="lex.html#Lex:STR:SPEC">Lex</A></CODE>.<CODE><A HREF="lex.html#SIG:LEX.tok:TY:SPEC">OpenPar</A></CODE></CODE>).  If, after reading a pair of symbols, the next element of the labeled token list is <CODE>&quot;,&quot;</CODE> (<CODE><CODE><A HREF="lex.html#Lex:STR:SPEC">Lex</A></CODE>.<CODE><A HREF="lex.html#SIG:LEX.tok:TY:SPEC">Comma</A></CODE></CODE>), then <CODE>inputFromLabToks</CODE> insists on reading another pair of symbols, even if this results in failure.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.fromString:VAL"></A>
<DT> <CODE>fromString <VAR>s</VAR></CODE>
<DD>
inputs a relation from <CODE><VAR>s</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.input:VAL"></A>
<DT> <CODE>input <VAR>fil</VAR></CODE>
<DD>
inputs a relation from the file <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.toPP:VAL"></A>
<DT> <CODE>toPP <VAR>rel</VAR></CODE>
<DD>
returns a pretty-printing expression for <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.toString:VAL"></A>
<DT> <CODE>toString <VAR>rel</VAR></CODE>
<DD>
pretty-prints <CODE><VAR>rel</VAR></CODE> to a string.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.output:VAL"></A>
<DT> <CODE>output(<VAR>fil</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
pretty-prints <CODE><VAR>rel</VAR></CODE> to file <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:SymRel.makeBijectionFromAvoiding:VAL"></A>
<DT> <CODE>makeBijectionFromAvoiding(<VAR>bs</VAR>, <VAR>cs</VAR>)</CODE>
<DD>
returns a bijection <CODE><VAR>rel</VAR></CODE> from <CODE><VAR>bs</VAR></CODE> to a set that's disjoint from <CODE><VAR>cs</VAR></CODE>.  If the set of all <CODE>(<VAR>b</VAR>, <VAR>b</VAR>)</CODE> such that <CODE><VAR>b</VAR></CODE> is in <CODE><VAR>bs</VAR></CODE> satisfies the disjointness property, it is returned. Otherwise, the set of all <CODE>(<VAR>b</VAR>, &lt;<VAR>b</VAR>&gt;)</CODE> such that <CODE><VAR>b</VAR></CODE> is in <CODE><VAR>bs</VAR></CODE> is tried, and then the set of all <CODE>(<VAR>b</VAR>, &lt;&lt;<VAR>b</VAR>&gt;&gt;)</CODE> such that <CODE><VAR>b</VAR></CODE> is in <CODE><VAR>bs</VAR></CODE>, etc., until a suitable relation is found.
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="sym-str-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.7</I><BR>
<I>Copyright &copy; 2018 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
