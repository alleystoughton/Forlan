<!-- HTML/set.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The Set Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>Set</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="SET:SIG:SPEC"></A><CODE>SET</CODE><BR>
<B>structure</B>&nbsp;<A NAME="Set:STR:SPEC"></A><CODE>Set</CODE><B> :> </B>SET<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module implements an abstract type of finite sets.
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<I>'a</I>&nbsp;<A NAME="STR:Set.set:TY:SPEC" HREF="#STR:Set.set:TY">set</A><BR>
<B>val</B>&nbsp;<A NAME="STR:Set.memb:VAL:SPEC" HREF="#STR:Set.memb:VAL">memb</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.fromList:VAL:SPEC" HREF="#STR:Set.fromList:VAL">fromList</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;list&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.toList:VAL:SPEC" HREF="#STR:Set.toList:VAL">toList</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;list<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.isEmpty:VAL:SPEC" HREF="#STR:Set.isEmpty:VAL">isEmpty</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.isNonEmpty:VAL:SPEC" HREF="#STR:Set.isNonEmpty:VAL">isNonEmpty</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.size:VAL:SPEC" HREF="#STR:Set.size:VAL">size</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.hd:VAL:SPEC" HREF="#STR:Set.hd:VAL">hd</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I><BR>
<B>val</B>&nbsp;<A NAME="STR:Set.tl:VAL:SPEC" HREF="#STR:Set.tl:VAL">tl</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.compare:VAL:SPEC" HREF="#STR:Set.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;order<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.subset:VAL:SPEC" HREF="#STR:Set.subset:VAL">subset</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.equal:VAL:SPEC" HREF="#STR:Set.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.all:VAL:SPEC" HREF="#STR:Set.all:VAL">all</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;bool)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.exists:VAL:SPEC" HREF="#STR:Set.exists:VAL">exists</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;bool)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.empty:VAL:SPEC" HREF="#STR:Set.empty:VAL">empty</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.sing:VAL:SPEC" HREF="#STR:Set.sing:VAL">sing</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.filter:VAL:SPEC" HREF="#STR:Set.filter:VAL">filter</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;bool)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.partition:VAL:SPEC" HREF="#STR:Set.partition:VAL">partition</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;bool)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.position:VAL:SPEC" HREF="#STR:Set.position:VAL">position</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;bool)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;int&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.map:VAL:SPEC" HREF="#STR:Set.map:VAL">map</A>&nbsp;<B>:</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;<I>'b</I>)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'b</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.mapFromList:VAL:SPEC" HREF="#STR:Set.mapFromList:VAL">mapFromList</A>&nbsp;<B>:</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;<I>'b</I>)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;list&nbsp;<B>-></B>&nbsp;<I>'b</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.mapToList:VAL:SPEC" HREF="#STR:Set.mapToList:VAL">mapToList</A>&nbsp;<B>:</B>&nbsp;(<I>'a</I>&nbsp;<B>-></B>&nbsp;<I>'b</I>)&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'b</I>&nbsp;list<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.union:VAL:SPEC" HREF="#STR:Set.union:VAL">union</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.genUnion:VAL:SPEC" HREF="#STR:Set.genUnion:VAL">genUnion</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;list&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.inter:VAL:SPEC" HREF="#STR:Set.inter:VAL">inter</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.genInter:VAL:SPEC" HREF="#STR:Set.genInter:VAL">genInter</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;list&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.minus:VAL:SPEC" HREF="#STR:Set.minus:VAL">minus</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.comparePair:VAL:SPEC" HREF="#STR:Set.comparePair:VAL">comparePair</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-></B>&nbsp;(<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>)&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.times:VAL:SPEC" HREF="#STR:Set.times:VAL">times</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;set&nbsp;<B>-></B>&nbsp;(<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>)&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.compareTriple:VAL:SPEC" HREF="#STR:Set.compareTriple:VAL">compareTriple</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>*</B>&nbsp;<I>'c</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;(<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>*</B>&nbsp;<I>'c</I>)&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.times3:VAL:SPEC" HREF="#STR:Set.times3:VAL">times3</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;set&nbsp;<B>*</B>&nbsp;<I>'c</I>&nbsp;set&nbsp;<B>-></B>&nbsp;(<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>*</B>&nbsp;<I>'c</I>)&nbsp;set<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.compareList:VAL:SPEC" HREF="#STR:Set.compareList:VAL">compareList</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;list&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:Set.genTimes:VAL:SPEC" HREF="#STR:Set.genTimes:VAL">genTimes</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;set&nbsp;list&nbsp;<B>-></B>&nbsp;<I>'a</I>&nbsp;list&nbsp;set</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:Set.set:TY"></A><CODE><B>type</B>&nbsp;<I>'a</I>&nbsp;set</CODE>
<DD>
This is the abstract type of finite sets of values of type <CODE><VAR>'a</VAR></CODE>.
<P>
The module's values are specified with the help of the abstract proposition saying that a value <CODE><VAR>xs</VAR></CODE> of type <CODE><VAR>'a</VAR> set</CODE> <EM>is compatible with</EM> a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.memb:VAL"></A>
<DT> <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
Informally, if <CODE><VAR>ys</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>memb</CODE> tests whether <CODE><VAR>x</VAR></CODE> is a member (element) of <CODE><VAR>ys</VAR></CODE>.  Formally, <CODE>memb</CODE> must be understood in relationship to the specifications of the module's other values.
<P>
In a context where we know that a value <CODE><VAR>xs</VAR></CODE> of type <CODE><VAR>'a</VAR> set</CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, when we say that <CODE><VAR>x</VAR></CODE> <EM>is an element of</EM> <CODE><VAR>xs</VAR></CODE>, this means that <CODE><VAR>x</VAR></CODE> is a value of type <CODE><VAR>'a</VAR></CODE> such that <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>, <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.fromList:VAL"></A>
<DT> <CODE>fromList <VAR>cmp</VAR> <VAR>xs</VAR></CODE>
<DD>
returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and whose elements are the elements of <CODE><VAR>xs</VAR></CODE>, i.e., the set <CODE><VAR>ys</VAR></CODE> such that: 
<UL>
<LI>
for all <CODE>1 &lt;= <VAR>i</VAR> &lt;= length <VAR>xs</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (List.sub(<VAR>xs</VAR>, i), <VAR>ys</VAR>)</CODE>;
<LI>
for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, if <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE>, then there is an <CODE>1 &lt;= <VAR>i</VAR> &lt;= length <VAR>xs</VAR></CODE> such that <CODE>Sort.equal <VAR>cmp</VAR> (<VAR>y</VAR>, List.sub(<VAR>xs</VAR>, i))</CODE>.
</UL>
<BR>
<BR>

<DT> <A NAME="STR:Set.toList:VAL"></A>
<DT> <CODE>toList <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>toList</CODE> returns the list consisting of the elements of <CODE><VAR>xs</VAR></CODE>, listed in strictly ascending order according to <CODE><VAR>cmp</VAR></CODE>, i.e., the list <CODE><VAR>ys</VAR></CODE> such that: 
<UL>
<LI>
<CODE>Sort.sorted (false, <VAR>cmp</VAR>) <VAR>ys</VAR></CODE>;
<LI>
for all values <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, if <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>, <VAR>xs</VAR>)</CODE>, then there is an <CODE>1 &lt;= <VAR>i</VAR> &lt;= length <VAR>ys</VAR></CODE> such that <CODE>Sort.equal <VAR>cmp</VAR> (<VAR>x</VAR>, List.sub(<VAR>ys</VAR>, i))</CODE>;
<LI>
for all <CODE>1 &lt;= <VAR>i</VAR> &lt;= length <VAR>ys</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (List.sub(<VAR>ys</VAR>, i), <VAR>xs</VAR>)</CODE>.
</UL>
<BR>
<BR>

<DT> <A NAME="STR:Set.isEmpty:VAL"></A>
<DT> <CODE>isEmpty <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>isEmpty</CODE> tests whether <CODE><VAR>xs</VAR></CODE> is empty, i.e., whether there is no value <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE> such that <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>, <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.isNonEmpty:VAL"></A>
<DT> <CODE>isNonEmpty <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>isNonEmpty</CODE> tests whether <CODE><VAR>xs</VAR></CODE> is nonempty, i.e., whether there is a value <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE> such that <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>, <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.size:VAL"></A>
<DT> <CODE>size <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>size</CODE> returns the size of <CODE><VAR>xs</VAR></CODE>, i.e., the length of <CODE>toList <VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.hd:VAL"></A>
<DT> <CODE>hd <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>hd</CODE> returns the <EM>head</EM> of <CODE><VAR>xs</VAR></CODE>, i.e., the first element of <CODE>toList <VAR>xs</VAR></CODE>. It raises <CODE>Empty</CODE> if this list is empty.
<BR>
<BR>

<DT> <A NAME="STR:Set.tl:VAL"></A>
<DT> <CODE>tl <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>tl</CODE> returns the <EM>tail</EM> of <CODE><VAR>xs</VAR></CODE>, i.e., <CODE>fromList <VAR>cmp</VAR> (tl(toList <VAR>xs</VAR>))</CODE>. It raises <CODE>Empty</CODE> if <CODE>toList <VAR>xs</VAR></CODE> is the empty list.
<BR>
<BR>

<DT> <A NAME="STR:Set.compare:VAL"></A>
<DT> <CODE>compare <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>compare</CODE> first compares <CODE>size <VAR>xs</VAR></CODE> and <CODE>size <VAR>ys</VAR></CODE>, returning <CODE>LESS</CODE> if the former is less than the latter, and <CODE>GREATER</CODE> if the former is greater than the latter.  If the sizes are equal, it works through the corresponding elements of <CODE>toList <VAR>xs</VAR></CODE> and <CODE>toList <VAR>ys</VAR></CODE>, using <CODE><VAR>cmp</VAR></CODE> to compare those elements, until a result of <CODE>LESS</CODE> or <CODE>GREATER</CODE> is found, in which case that result in returned.  If all comparisons result in <CODE>EQUAL</CODE>, then <CODE>compare</CODE> returns <CODE>EQUAL</CODE>.
<P>
Unfortunately, <CODE>compare <VAR>cmp</VAR></CODE> isn't an <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>. But does satisfy the formulas of the definition of <CODE><VAR>'a</VAR> set Sort.total_ordering</CODE> for all values <CODE><VAR>xs</VAR></CODE>, <CODE><VAR>ys</VAR></CODE> and <CODE><VAR>zs</VAR></CODE> of type <CODE><VAR>'a</VAR> set</CODE> that <EM>are compatible with</EM> <CODE><VAR>cmp</VAR></CODE>.  In addition, we have that <CODE>compare <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>) = EQUAL</CODE> iff <CODE>equal <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>, where the function <CODE>equal</CODE> is specified below.
<BR>
<BR>

<DT> <A NAME="STR:Set.subset:VAL"></A>
<DT> <CODE>subset <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>subset</CODE> tests whether <CODE><VAR>xs</VAR></CODE> is a subset of <CODE><VAR>ys</VAR></CODE>, i.e., whether, for all values <CODE><VAR>z</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, if <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>xs</VAR>)</CODE>, then <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>ys</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.equal:VAL"></A>
<DT> <CODE>equal <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>equal</CODE> tests whether <CODE><VAR>xs</VAR></CODE> is equal to <CODE><VAR>ys</VAR></CODE>, i.e., whether, for all values <CODE><VAR>z</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>xs</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>ys</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.all:VAL"></A>
<DT> <CODE>all <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>all</CODE> tests whether, for all elements <CODE><VAR>x</VAR></CODE> of <CODE><VAR>xs</VAR></CODE>, <CODE><VAR>f</VAR> <VAR>x</VAR></CODE>, i.e., whether, for all values <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, if <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>,
<VAR>xs</VAR>)</CODE>, then <CODE><VAR>f</VAR> <VAR>x</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.exists:VAL"></A>
<DT> <CODE>exists <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>exists</CODE> tests whether, there is an element <CODE><VAR>x</VAR></CODE> of <CODE><VAR>xs</VAR></CODE> such that <CODE><VAR>f</VAR> <VAR>x</VAR></CODE>, i.e., whether there is a value <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE> such that <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>,
<VAR>xs</VAR>)</CODE> and <CODE><VAR>f</VAR> <VAR>x</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.empty:VAL"></A>
<DT> <CODE>empty</CODE>
<DD>
If <CODE><VAR>cmp</VAR></CODE> is a value of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>empty</CODE> is the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and has no elements, i.e., the set <CODE><VAR>xs</VAR></CODE> such that there is no value <CODE><VAR>x</VAR></CODE> of <CODE><VAR>'a</VAR></CODE> such that <CODE>memb <VAR>cmp</VAR> (<VAR>x</VAR>,
<VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.sing:VAL"></A>
<DT> <CODE>sing <VAR>x</VAR></CODE>
<DD>
If <CODE><VAR>cmp</VAR></CODE> is a value of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>sing</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and whose only element is <CODE><VAR>x</VAR></CODE>, i.e., the set <CODE><VAR>ys</VAR></CODE> such that, for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE> iff <CODE>Sort.equal <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>x</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.filter:VAL"></A>
<DT> <CODE>filter <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>filter</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and consists of the elements of <CODE><VAR>xs</VAR></CODE> on which <CODE><VAR>f</VAR></CODE> returns <CODE>true</CODE>, i.e., the set <CODE><VAR>ys</VAR></CODE> such that, for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>xs</VAR>)</CODE> and <CODE>f <VAR>y</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.partition:VAL"></A>
<DT> <CODE>partition <VAR>f</VAR> <VAR>xs</VAR> </CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>filter</CODE> returns the pair of sets <CODE>(<VAR>ys</VAR>, <VAR>zs</VAR>)</CODE> such that <CODE><VAR>ys</VAR></CODE> and <CODE><VAR>zs</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, <CODE><VAR>ys</VAR></CODE> consists of the elements of <CODE><VAR>xs</VAR></CODE> on which <CODE><VAR>f</VAR></CODE> returns <CODE>true</CODE>, and <CODE><VAR>zs</VAR></CODE> consists of the elements of <CODE><VAR>xs</VAR></CODE> on which <CODE><VAR>f</VAR></CODE> returns <CODE>false</CODE>, i.e., such that 
<UL>
<LI>
for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>xs</VAR>)</CODE> and <CODE>f <VAR>y</VAR></CODE>;
<LI>
for all values <CODE><VAR>z</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>zs</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>xs</VAR>)</CODE> and <CODE>not(f <VAR>z</VAR>)</CODE>.
</UL>
<BR>
<BR>

<DT> <A NAME="STR:Set.position:VAL"></A>
<DT> <CODE>position <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>position</CODE> behaves the same as <CODE>ListAux.position <VAR>f</VAR> (toList <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.map:VAL"></A>
<DT> <CODE>map <VAR>cmp'</VAR> <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>cmp</VAR></CODE> is a value of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, <CODE><VAR>cmp'</VAR></CODE> is a value of type <CODE><VAR>'b</VAR> Sort.total_ordering</CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>map</CODE> returns the set that is compatible with <CODE><VAR>cmp'</VAR></CODE> and consists of the set of all <CODE><VAR>f</VAR> <VAR>x</VAR></CODE> such that <CODE><VAR>x</VAR></CODE> is in <CODE><VAR>xs</VAR></CODE>, i.e., the set <CODE><VAR>ys</VAR></CODE> such that, for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'b</VAR></CODE>, <CODE>memb
<VAR>cmp'</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE> iff <CODE>Sort.equal
<VAR>cmp'</VAR> (<VAR>y</VAR>, <VAR>f</VAR> <VAR>x</VAR>)</CODE>, for some value <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE> such that <CODE>memb
<VAR>cmp</VAR> (<VAR>x</VAR>, <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.mapFromList:VAL"></A>
<DT> <CODE>mapFromList <VAR>cmp</VAR> <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>cmp</VAR></CODE> is a value of type <CODE><VAR>'b</VAR> total_ordering</CODE>, then <CODE>mapFromList</CODE> returns <CODE>fromList <VAR>cmp</VAR> (map <VAR>f</VAR> <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.mapToList:VAL"></A>
<DT> <CODE>mapToList <VAR>f</VAR> <VAR>xs</VAR></CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>mapToList</CODE> returns <CODE>map <VAR>f</VAR> (toList <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.union:VAL"></A>
<DT> <CODE>union <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>union</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and is the union of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>, i.e., the set <CODE><VAR>zs</VAR></CODE> such that, for all values <CODE><VAR>z</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>zs</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>xs</VAR>)</CODE> or <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>ys</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.genUnion:VAL"></A>
<DT> <CODE>genUnion <VAR>cmp</VAR> <VAR>xss</VAR></CODE>
<DD>
If all the elements of <CODE><VAR>xss</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>genUnion</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and is the generalized union of the elements of <CODE><VAR>xss</VAR></CODE>, i.e., the set <CODE><VAR>ys</VAR></CODE> such that, for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>,  <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE> iff there is an element <CODE><VAR>xs</VAR></CODE> of <CODE><VAR>xss</VAR></CODE> such that <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>xs</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.inter:VAL"></A>
<DT> <CODE>inter <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>inter</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and is the intersection of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>, i.e., the set <CODE><VAR>zs</VAR></CODE> such that, for all values <CODE><VAR>z</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>zs</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>xs</VAR>)</CODE> and <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>ys</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.genInter:VAL"></A>
<DT> <CODE>genInter <VAR>cmp</VAR> <VAR>xss</VAR></CODE>
<DD>
If all the elements of <CODE><VAR>xss</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>genInter</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and is the generalized intersection of the elements of <CODE><VAR>xss</VAR></CODE>, i.e., the set <CODE><VAR>ys</VAR></CODE> such that, for all values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>ys</VAR>)</CODE> iff for all elements <CODE><VAR>xs</VAR></CODE> of <CODE><VAR>xss</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>y</VAR>, <VAR>xs</VAR>)</CODE>. An error message is issued when <CODE><VAR>xss</VAR></CODE> is the empty list.
<BR>
<BR>

<DT> <A NAME="STR:Set.minus:VAL"></A>
<DT> <CODE>minus <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE> are compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>minus</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and is the difference of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>, i.e., the set zs such that, for all values <CODE><VAR>z</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>zs</VAR>)</CODE> iff <CODE>memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>xs</VAR>)</CODE> and <CODE>not(memb <VAR>cmp</VAR> (<VAR>z</VAR>, <VAR>ys</VAR>))</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.comparePair:VAL"></A>
<DT> <CODE>comparePair (<VAR>cmp1</VAR>, <VAR>cmp2</VAR>) ((<VAR>x</VAR>, <VAR>y</VAR>), (<VAR>x'</VAR>, <VAR>y'</VAR>))</CODE>
<DD>
works lexicographically, first using <CODE><VAR>cmp1</VAR></CODE> on <CODE>(<VAR>x</VAR>, <VAR>x'</VAR>)</CODE>, and then using <CODE><VAR>cmp2</VAR></CODE> on <CODE>(<VAR>y</VAR>, <VAR>y'</VAR>)</CODE>.  I.e., it returns 
<PRE>
  case <VAR>cmp1</VAR>(<VAR>x</VAR>, <VAR>x'</VAR>) of
       LESS    =&gt; LESS
     | EQUAL   =&gt; <VAR>cmp2</VAR>(<VAR>y</VAR>, <VAR>y'</VAR>)
     | GREATER =&gt; GREATER
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:Set.times:VAL"></A>
<DT> <CODE>times(<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with a value <CODE><VAR>cmp1</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, and <CODE><VAR>ys</VAR></CODE> is compatible with a value <CODE><VAR>cmp2</VAR></CODE> of type <CODE><VAR>'b</VAR> Sort.total_ordering</CODE>, then <CODE>times</CODE> returns the set that is compatible with <CODE>comparePair(<VAR>cmp1</VAR>, <VAR>cmp2</VAR>)</CODE> and is the product of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>, i.e., the set <CODE><VAR>zs</VAR></CODE> such that, for all values <CODE><VAR>p</VAR></CODE> of type <CODE><VAR>'a</VAR> * <VAR>'b</VAR></CODE>, <CODE>memb (compairPair(<VAR>cmp1</VAR>, <VAR>cmp2</VAR>)) (<VAR>p</VAR>, <VAR>zs</VAR>)</CODE> iff <CODE>memb <VAR>cmp1</VAR> (#1 <VAR>p</VAR>, <VAR>xs</VAR>)</CODE> and <CODE>memb <VAR>cmp2</VAR> (#2 <VAR>p</VAR>, <VAR>ys</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.compareTriple:VAL"></A>
<DT> <CODE>compareTriple</CODE>
<DD>
is like <CODE>comparePair</CODE>, but for triples.
<BR>
<BR>

<DT> <A NAME="STR:Set.times3:VAL"></A>
<DT> <CODE>times3</CODE>
<DD>
is like <CODE>times</CODE>, but for triples, ordered using <CODE>compareTriple</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.compareList:VAL"></A>
<DT> <CODE>compareList <VAR>cmp</VAR> (<VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
first compares the lengths of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>, returning <CODE>LESS</CODE>, if <CODE><VAR>xs</VAR></CODE> is shorter than <CODE><VAR>ys</VAR></CODE>, and <CODE>GREATER</CODE>, if <CODE><VAR>xs</VAR></CODE> is longer than <CODE><VAR>ys</VAR></CODE>. When the lengths are equal, it works lexicographically, using <CODE><VAR>cmp</VAR></CODE> to compare corresponding elements of <CODE><VAR>xs</VAR></CODE> and <CODE><VAR>ys</VAR></CODE>, and yielding the first non-<CODE>EQUAL</CODE> result.  If all comparisons result in <CODE>EQUAL</CODE>, then <CODE>compareList</CODE> returns <CODE>EQUAL</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Set.genTimes:VAL"></A>
<DT> <CODE>genTimes <VAR>xss</VAR></CODE>
<DD>
If all the elements of <CODE><VAR>xss</VAR></CODE> are compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>genTimes</CODE> returns the set that is compatible with <CODE>compareList <VAR>cmp</VAR></CODE> and is the generalized product of the elements of <CODE><VAR>xss</VAR></CODE>, i.e., the set <CODE><VAR>yss</VAR></CODE> such that, for all values <CODE><VAR>ys</VAR></CODE> of type <CODE><VAR>'a</VAR> list</CODE>, <CODE>memb (compareList <VAR>cmp</VAR>) (<VAR>ys</VAR>, <VAR>yss</VAR>)</CODE> iff <CODE>length <VAR>ys</VAR> = length <VAR>xss</VAR></CODE> and, for all <CODE>1 &lt;= i &lt;= length <VAR>xss</VAR></CODE>, <CODE>memb <VAR>cmp</VAR> (ListAux.sub(<VAR>ys</VAR>, i), ListAux.sub(<VAR>xss</VAR>, i))</CODE>.
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="sort-set-rel-tab-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.11</I><BR>
<I>Copyright &copy; 2019 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
