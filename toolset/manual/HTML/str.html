<!-- HTML/str.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The Str Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>Str</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="STR:SIG:SPEC"></A><CODE>STR</CODE><BR>
<B>structure</B>&nbsp;<A NAME="Str:STR:SPEC"></A><CODE>Str</CODE><B> :> </B>STR<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module provides operations on Forlan strings, i.e., lists of Forlan symbols.
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<A NAME="STR:Str.str:TY:SPEC" HREF="#STR:Str.str:TY">str</A>&nbsp;=&nbsp;Sym.sym&nbsp;list<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.possBeginsWithStr:VAL:SPEC" HREF="#STR:Str.possBeginsWithStr:VAL">possBeginsWithStr</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.inputFromLabToks:VAL:SPEC" HREF="#STR:Str.inputFromLabToks:VAL">inputFromLabToks</A>&nbsp;<B>:</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;str&nbsp;<B>*</B>&nbsp;(int&nbsp;<B>*</B>&nbsp;Lex.tok)&nbsp;list<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.fromString:VAL:SPEC" HREF="#STR:Str.fromString:VAL">fromString</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;str<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.input:VAL:SPEC" HREF="#STR:Str.input:VAL">input</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;str<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.toPP:VAL:SPEC" HREF="#STR:Str.toPP:VAL">toPP</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;PP.pp<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.toString:VAL:SPEC" HREF="#STR:Str.toString:VAL">toString</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;string<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.output:VAL:SPEC" HREF="#STR:Str.output:VAL">output</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.last:VAL:SPEC" HREF="#STR:Str.last:VAL">last</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;Sym.sym<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.allButLast:VAL:SPEC" HREF="#STR:Str.allButLast:VAL">allButLast</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;str<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.compare:VAL:SPEC" HREF="#STR:Str.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;str&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.equal:VAL:SPEC" HREF="#STR:Str.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.alphabet:VAL:SPEC" HREF="#STR:Str.alphabet:VAL">alphabet</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.renameAlphabet:VAL:SPEC" HREF="#STR:Str.renameAlphabet:VAL">renameAlphabet</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-&gt;</B>&nbsp;str<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.prefix:VAL:SPEC" HREF="#STR:Str.prefix:VAL">prefix</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.suffix:VAL:SPEC" HREF="#STR:Str.suffix:VAL">suffix</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.substr:VAL:SPEC" HREF="#STR:Str.substr:VAL">substr</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.power:VAL:SPEC" HREF="#STR:Str.power:VAL">power</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;int&nbsp;<B>-&gt;</B>&nbsp;str<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.removePrefix:VAL:SPEC" HREF="#STR:Str.removePrefix:VAL">removePrefix</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;str&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.removeSuffix:VAL:SPEC" HREF="#STR:Str.removeSuffix:VAL">removeSuffix</A>&nbsp;<B>:</B>&nbsp;str&nbsp;<B>*</B>&nbsp;str&nbsp;<B>-&gt;</B>&nbsp;str&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.jforlanValidate:VAL:SPEC" HREF="#STR:Str.jforlanValidate:VAL">jforlanValidate</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:Str.jforlanPretty:VAL:SPEC" HREF="#STR:Str.jforlanPretty:VAL">jforlanPretty</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;unit</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:Str.str:TY"></A><CODE><B>type</B>&nbsp;str&nbsp;=&nbsp;Sym.sym&nbsp;list</CODE>
<DD>
The type of Forlan strings, i.e., lists of Forlan symbols.
<P>
In the concrete syntax for strings, the empty string is written as <CODE>%</CODE>, and a nonempty string <CODE>[<VAR>a1</VAR>, ... <VAR>an</VAR>]</CODE> is written as <CODE><VAR>a1</VAR> ... <VAR>an</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.possBeginsWithStr:VAL"></A>
<DT> <CODE>possBeginsWithStr <VAR>lts</VAR></CODE>
<DD>
tests whether <CODE><VAR>lts</VAR></CODE> begins with a symbol or <CODE>%</CODE> (<CODE><CODE><A HREF="lex.html#Lex:STR:SPEC">Lex</A></CODE>.<CODE><A HREF="lex.html#SIG:LEX.tok:TY:SPEC">Perc</A></CODE></CODE>), making it possible that a Forlan string could be parsed from <CODE><VAR>lts</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.inputFromLabToks:VAL"></A>
<DT> <CODE>inputFromLabToks <VAR>lts</VAR></CODE>
<DD>
tries to input a Forlan string from <CODE><VAR>lts</VAR></CODE>, consuming as much of <CODE><VAR>lts</VAR></CODE> as possible, and returning the pair of that string and the rest of <CODE><VAR>lts</VAR></CODE>.  Issues an error message if this can't be done.
<BR>
<BR>

<DT> <A NAME="STR:Str.fromString:VAL"></A>
<DT> <CODE>fromString <VAR>s</VAR></CODE>
<DD>
inputs a Forlan string from <CODE><VAR>s</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.input:VAL"></A>
<DT> <CODE>input <VAR>fil</VAR></CODE>
<DD>
inputs a Forlan string from the file named by <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.toPP:VAL"></A>
<DT> <CODE>toPP <VAR>x</VAR></CODE>
<DD>
returns a pretty-printing expression for <CODE><VAR>x</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.toString:VAL"></A>
<DT> <CODE>toString <VAR>x</VAR></CODE>
<DD>
pretty-prints <CODE><VAR>x</VAR></CODE> to a string.
<BR>
<BR>

<DT> <A NAME="STR:Str.output:VAL"></A>
<DT> <CODE>output(<VAR>fil</VAR>, <VAR>x</VAR>)</CODE>
<DD>
pretty-prints <CODE><VAR>x</VAR></CODE> to the file named by <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.last:VAL"></A>
<DT> <CODE>last x</CODE>
<DD>
returns the last element of <CODE><VAR>x</VAR></CODE>. Raises <CODE>Empty</CODE> if <CODE><VAR>x</VAR></CODE> is empty.
<BR>
<BR>

<DT> <A NAME="STR:Str.allButLast:VAL"></A>
<DT> <CODE>last x</CODE>
<DD>
returns all but the last element of <CODE><VAR>x</VAR></CODE>. Raises <CODE>Empty</CODE> if <CODE><VAR>x</VAR></CODE> is empty.
<BR>
<BR>

<DT> <A NAME="STR:Str.compare:VAL"></A>
<DT> <CODE>compare</CODE>
<DD>
is defined by: 
<PRE>
  val compare = Set.compareList Sym.compare
</PRE>
 This ordering first uses the length of strings (shorter is smaller), and then uses the lexicographic ordering on equal length strings.
<BR>
<BR>

<DT> <A NAME="STR:Str.equal:VAL"></A>
<DT> <CODE>equal(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> and <CODE><VAR>y</VAR></CODE> are equal.
<BR>
<BR>

<DT> <A NAME="STR:Str.alphabet:VAL"></A>
<DT> <CODE>alphabet <VAR>x</VAR></CODE>
<DD>
returns the alphabet of <CODE><VAR>x</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.renameAlphabet:VAL"></A>
<DT> <CODE>renameAlphabet(<VAR>x</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
renames the alphabet of <CODE><VAR>x</VAR></CODE> using the bijection <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> is not a bijection from a superset of the alphabet of <CODE><VAR>x</VAR></CODE> to some set.
<BR>
<BR>

<DT> <A NAME="STR:Str.prefix:VAL"></A>
<DT> <CODE>prefix(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> is a prefix of <CODE><VAR>y</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.suffix:VAL"></A>
<DT> <CODE>suffix(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> is a suffix of <CODE><VAR>y</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.substr:VAL"></A>
<DT> <CODE>substr(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> is a substring of <CODE><VAR>y</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.power:VAL"></A>
<DT> <CODE>power(<VAR>x</VAR>, <VAR>n</VAR>)</CODE>
<DD>
raises <CODE><VAR>x</VAR></CODE> to the power <CODE><VAR>n</VAR></CODE>. Issues an error message if <CODE><VAR>n</VAR></CODE> is negative.
<BR>
<BR>

<DT> <A NAME="STR:Str.removePrefix:VAL"></A>
<DT> <CODE>removePrefix(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
If <CODE><VAR>x</VAR></CODE> is a prefix of <CODE><VAR>y</VAR></CODE>, then <CODE>removePrefix</CODE> returns <CODE>SOME <VAR>z</VAR></CODE>, where <CODE><VAR>z</VAR></CODE> is the result of removing <CODE><VAR>x</VAR></CODE> from the beginning of <CODE><VAR>y</VAR></CODE>.  Otherwise, <CODE>removePrefix</CODE> returns <CODE>NONE</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.removeSuffix:VAL"></A>
<DT> <CODE>removeSuffix(<VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
If <CODE><VAR>x</VAR></CODE> is a suffix of <CODE><VAR>y</VAR></CODE>, then <CODE>removeSuffix</CODE> returns <CODE>SOME <VAR>z</VAR></CODE>, where <CODE><VAR>z</VAR></CODE> is the result of removing <CODE><VAR>x</VAR></CODE> from the end of <CODE><VAR>y</VAR></CODE>.  Otherwise, <CODE>removeSuffix</CODE> returns <CODE>NONE</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Str.jforlanValidate:VAL"></A>
<DT> <CODE>jforlanValidate</CODE>
<DD>
is a low-level function used by JForlan.  See the code for more information.
<BR>
<BR>

<DT> <A NAME="STR:Str.jforlanPretty:VAL"></A>
<DT> <CODE>jforlanPretty</CODE>
<DD>
is a low-level function used by JForlan.  See the code for more information.
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="sym-str-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.11</I><BR>
<I>Copyright &copy; 2019 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
