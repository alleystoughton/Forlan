<!-- HTML/rel.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The Rel Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>Rel</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="REL:SIG:SPEC"></A><CODE>REL</CODE><BR>
<B>structure</B>&nbsp;<A NAME="Rel:STR:SPEC"></A><CODE>Rel</CODE><B> :> </B>REL<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module provides various operations on finite relations, i.e., finite sets of ordered pairs.
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;(<I>'a</I>,<I>'b</I>)&nbsp;<A NAME="STR:Rel.rel:TY:SPEC" HREF="#STR:Rel.rel:TY">rel</A>&nbsp;=&nbsp;(<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>)&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.domain:VAL:SPEC" HREF="#STR:Rel.domain:VAL">domain</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.range:VAL:SPEC" HREF="#STR:Rel.range:VAL">range</A>&nbsp;<B>:</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.relationFromTo:VAL:SPEC" HREF="#STR:Rel.relationFromTo:VAL">relationFromTo</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.relationOn:VAL:SPEC" HREF="#STR:Rel.relationOn:VAL">relationOn</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.apply:VAL:SPEC" HREF="#STR:Rel.apply:VAL">apply</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.reflexive:VAL:SPEC" HREF="#STR:Rel.reflexive:VAL">reflexive</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.symmetric:VAL:SPEC" HREF="#STR:Rel.symmetric:VAL">symmetric</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.antisymmetric:VAL:SPEC" HREF="#STR:Rel.antisymmetric:VAL">antisymmetric</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.transitive:VAL:SPEC" HREF="#STR:Rel.transitive:VAL">transitive</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.total:VAL:SPEC" HREF="#STR:Rel.total:VAL">total</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.inverse:VAL:SPEC" HREF="#STR:Rel.inverse:VAL">inverse</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;(<I>'b</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.reflexiveClosure:VAL:SPEC" HREF="#STR:Rel.reflexiveClosure:VAL">reflexiveClosure</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.transitiveClosure:VAL:SPEC" HREF="#STR:Rel.transitiveClosure:VAL">transitiveClosure</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.reflexiveTransitiveClosure:VAL:SPEC" HREF="#STR:Rel.reflexiveTransitiveClosure:VAL">reflexiveTransitiveClosure</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.symmetricClosure:VAL:SPEC" HREF="#STR:Rel.symmetricClosure:VAL">symmetricClosure</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.transitiveSymmetricClosure:VAL:SPEC" HREF="#STR:Rel.transitiveSymmetricClosure:VAL">transitiveSymmetricClosure</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.reflexiveTransitiveSymmetricClosure:VAL:SPEC" HREF="#STR:Rel.reflexiveTransitiveSymmetricClosure:VAL">reflexiveTransitiveSymmetricClosure</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'a</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.compose:VAL:SPEC" HREF="#STR:Rel.compose:VAL">compose</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'c</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'b</I>,&nbsp;<I>'c</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'c</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.function:VAL:SPEC" HREF="#STR:Rel.function:VAL">function</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.functionFromTo:VAL:SPEC" HREF="#STR:Rel.functionFromTo:VAL">functionFromTo</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.injection:VAL:SPEC" HREF="#STR:Rel.injection:VAL">injection</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.bijectionFromTo:VAL:SPEC" HREF="#STR:Rel.bijectionFromTo:VAL">bijectionFromTo</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.bijectionFromAvoiding:VAL:SPEC" HREF="#STR:Rel.bijectionFromAvoiding:VAL">bijectionFromAvoiding</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.bijectionFromSupersetAvoiding:VAL:SPEC" HREF="#STR:Rel.bijectionFromSupersetAvoiding:VAL">bijectionFromSupersetAvoiding</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.applyFunction:VAL:SPEC" HREF="#STR:Rel.applyFunction:VAL">applyFunction</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>-&gt;</B>&nbsp;<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I><BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.restrictFunction:VAL:SPEC" HREF="#STR:Rel.restrictFunction:VAL">restrictFunction</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.updateFunction:VAL:SPEC" HREF="#STR:Rel.updateFunction:VAL">updateFunction</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel<BR>
<B>val</B>&nbsp;<A NAME="STR:Rel.mlFunctionToFunction:VAL:SPEC" HREF="#STR:Rel.mlFunctionToFunction:VAL">mlFunctionToFunction</A>&nbsp;<B>:</B>&nbsp;<I>'a</I>&nbsp;Sort.total_ordering&nbsp;<B>*</B>&nbsp;<I>'b</I>&nbsp;Sort.total_ordering<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>&nbsp;<B>-&gt;</B>&nbsp;<I>'b</I>)&nbsp;<B>*</B>&nbsp;<I>'a</I>&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;(<I>'a</I>,&nbsp;<I>'b</I>)&nbsp;rel</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:Rel.rel:TY"></A><CODE><B>type</B>&nbsp;(<I>'a</I>,<I>'b</I>)&nbsp;rel&nbsp;=&nbsp;(<I>'a</I>&nbsp;<B>*</B>&nbsp;<I>'b</I>)&nbsp;Set.set</CODE>
<DD>
The type of finite relations from values of type <CODE><VAR>'a</VAR></CODE> to values of type <CODE><VAR>'b</VAR></CODE>, i.e., finite sets of values of type <CODE><VAR>'a</VAR> * <VAR>'b</VAR></CODE>.
<P>
The module's values are specified with the help of the abstract proposition saying that a value <CODE><VAR>rel</VAR></CODE> of type <CODE>(<VAR>'a</VAR>, <VAR>'b</VAR>)rel</CODE> <EM>is compatible with</EM> a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE> and a value <CODE><VAR>cmp'</VAR></CODE> of type <CODE><VAR>'b</VAR> Sort.total_ordering</CODE>.
<P>
In a context where we know that a value <CODE><VAR>rel</VAR></CODE> of type <CODE>(<VAR>'a</VAR>, <VAR>'b</VAR>)rel</CODE> is compatible with a values <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE> of types <CODE><VAR>'a</VAR> Sort.total_ordering</CODE> and <CODE><VAR>'b</VAR> Sort.total_ordering</CODE>, respectively, when we say that <CODE>(<VAR>x</VAR>, <VAR>y</VAR>)</CODE> <EM>is an element (or member) of</EM> <CODE><VAR>rel</VAR></CODE>, this means that <CODE><VAR>x</VAR></CODE> and <CODE><VAR>y</VAR></CODE> are values of types <CODE><VAR>'a</VAR></CODE> and <CODE><VAR>'b</VAR></CODE>, respectively, such that <CODE>Set.memb (Set.comparePair(<VAR>cmp</VAR>, <VAR>cmp'</VAR>))
((<VAR>x</VAR>, <VAR>y</VAR>), <VAR>rel</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.domain:VAL"></A>
<DT> <CODE>domain <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and a value <CODE><VAR>cmp'</VAR></CODE> of type <CODE><VAR>'b</VAR> Sort.total_ordering</CODE>, then <CODE>domain</CODE> returns the set that is compatible with <CODE><VAR>cmp</VAR></CODE> and is the domain of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.range:VAL"></A>
<DT> <CODE>range <VAR>cmp'</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with a value <CODE><VAR>cmp</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE> and <CODE><VAR>cmp'</VAR></CODE>, then <CODE>range</CODE> returns the set that is compatible with <CODE><VAR>cmp'</VAR></CODE> and is the range of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.relationFromTo:VAL"></A>
<DT> <CODE>relationFromTo (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>ys</VAR></CODE> is compatible with <CODE><VAR>cmp'</VAR></CODE>, then <CODE>relationFromTo</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a relation from <CODE><VAR>xs</VAR></CODE> to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.relationOn:VAL"></A>
<DT> <CODE>relationOn <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>relationOn</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a relation on <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.apply:VAL"></A>
<DT> <CODE>apply (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>apply</CODE> returns the set that is compatible with <CODE><VAR>cmp'</VAR></CODE> and whose elements are all those values <CODE><VAR>y</VAR></CODE> of type <CODE><VAR>'b</VAR></CODE> such that there is a value <CODE><VAR>x</VAR></CODE> of type <CODE><VAR>'a</VAR></CODE> such that <CODE><VAR>x</VAR></CODE> is a member of <CODE><VAR>xs</VAR></CODE> and <CODE>(<VAR>x</VAR>, <VAR>y</VAR>)</CODE> is a member of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.reflexive:VAL"></A>
<DT> <CODE>reflexive <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>reflexive</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is reflexive on <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.symmetric:VAL"></A>
<DT> <CODE>symmetric <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, then <CODE>symmetric</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is symmetric.
<BR>
<BR>

<DT> <A NAME="STR:Rel.antisymmetric:VAL"></A>
<DT> <CODE>antisymmetric <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, then <CODE>antisymmetric</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is antisymmetric.
<BR>
<BR>

<DT> <A NAME="STR:Rel.transitive:VAL"></A>
<DT> <CODE>transitive <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, then <CODE>symmetric</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is transitive.
<BR>
<BR>

<DT> <A NAME="STR:Rel.total:VAL"></A>
<DT> <CODE>total <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>total</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is total on <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.inverse:VAL"></A>
<DT> <CODE>inverse (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, then <CODE>inverse</CODE> returns the inverse of <CODE><VAR>rel</VAR></CODE>, which is compatible with <CODE><VAR>cmp'</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.reflexiveClosure:VAL"></A>
<DT> <CODE>reflexiveClosure <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>reflexiveClosure</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE> and is the reflexive closure of <CODE><VAR>rel</VAR></CODE> with respect to <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.transitiveClosure:VAL"></A>
<DT> <CODE>transitiveClosure <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, then <CODE>transitiveClosure</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE> and is the transitive closure of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.reflexiveTransitiveClosure:VAL"></A>
<DT> <CODE>reflexiveTransitiveClosure <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>reflexiveTransitiveClosure</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and and <CODE><VAR>cmp</VAR></CODE> and is the reflexive, transitive closure of <CODE><VAR>rel</VAR></CODE> with respect to <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.symmetricClosure:VAL"></A>
<DT> <CODE>symmetricClosure <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, then <CODE>symmetricClosure</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE> and is the symmetric closure of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.transitiveSymmetricClosure:VAL"></A>
<DT> <CODE>transitiveSymmetricClosure <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, then <CODE>transitiveSymmetricClosure</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE> and is the transitive, symmetric closure of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.reflexiveTransitiveSymmetricClosure:VAL"></A>
<DT> <CODE>reflexiveTransitiveSymmetricClosure <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>reflexiveTransitiveSymmetricClosure</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp</VAR></CODE> and is the reflexive, transitive, symmetric closure of <CODE><VAR>rel</VAR></CODE> with respect to <CODE><VAR>xs</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.compose:VAL"></A>
<DT> <CODE>compose (<VAR>cmp</VAR>, <VAR>cmp'</VAR>, <VAR>cmp''</VAR>) (<VAR>rel2</VAR>, <VAR>rel1</VAR>)</CODE>
<DD>
If <CODE><VAR>rel2</VAR></CODE> is compatible with <CODE><VAR>cmp'</VAR></CODE> and <CODE><VAR>cmp''</VAR></CODE>, and <CODE><VAR>rel1</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, then <CODE>compose</CODE> returns the relation that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp''</VAR></CODE> and is the composition of <CODE><VAR>rel2</VAR></CODE> and <CODE><VAR>rel1</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.function:VAL"></A>
<DT> <CODE>function <VAR>cmp</VAR> <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and a value <CODE><VAR>cmp'</VAR></CODE> of type <CODE><VAR>'a</VAR> Sort.total_ordering</CODE>, then <CODE>function</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a function.
<BR>
<BR>

<DT> <A NAME="STR:Rel.functionFromTo:VAL"></A>
<DT> <CODE>functionFromTo (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>ys</VAR></CODE> is compatible with <CODE><VAR>cmp'</VAR></CODE>, then <CODE>functionFromTo</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a function from <CODE><VAR>xs</VAR></CODE> to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.injection:VAL"></A>
<DT> <CODE>injection (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) <VAR>rel</VAR></CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, then <CODE>injection</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is an injection.
<BR>
<BR>

<DT> <A NAME="STR:Rel.bijectionFromTo:VAL"></A>
<DT> <CODE>bijectionFromTo (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>ys</VAR></CODE> is compatible with <CODE><VAR>cmp'</VAR></CODE>, then <CODE>bijectionFromTo</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a bijection from <CODE><VAR>xs</VAR></CODE> to <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.bijectionFromAvoiding:VAL"></A>
<DT> <CODE>bijectionFromAvoiding (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>ys</VAR></CODE> is compatible with <CODE><VAR>cmp'</VAR></CODE>, then <CODE>bijectionFromAvoiding</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a bijection from <CODE><VAR>xs</VAR></CODE> to a set that is disjoint from <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.bijectionFromSupersetAvoiding:VAL"></A>
<DT> <CODE>bijectionFromSupersetAvoiding (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>, <VAR>ys</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, and <CODE><VAR>ys</VAR></CODE> is compatible with <CODE><VAR>cmp'</VAR></CODE>, then <CODE>bijectionFromSupersetAvoiding</CODE> tests whether <CODE><VAR>rel</VAR></CODE> is a bijection from a superset of <CODE><VAR>xs</VAR></CODE> to a set that is disjoint from <CODE><VAR>ys</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.applyFunction:VAL"></A>
<DT> <CODE>applyFunction <VAR>cmp</VAR> (<VAR>rel</VAR>, <VAR>x</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and a value <CODE><VAR>cmp'</VAR></CODE> of type <CODE><VAR>'b</VAR> Sort.total_ordering</CODE>, then <CODE>applyFunction</CODE> applies the function <CODE><VAR>rel</VAR></CODE> to <CODE><VAR>x</VAR></CODE>.  It issues an error message if <CODE><VAR>rel</VAR></CODE> is not a function, or if <CODE><VAR>x</VAR></CODE> is not in the domain of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.restrictFunction:VAL"></A>
<DT> <CODE>restrictFunction (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, and <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>restrictFunction</CODE> returns the function that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE> and is the restriction of <CODE><VAR>rel</VAR></CODE> to <CODE><VAR>xs</VAR></CODE>. Issues an error message if <CODE><VAR>rel</VAR></CODE> isn't a function, or if <CODE><VAR>xs</VAR></CODE> isn't a subset of the domain of <CODE><VAR>rel</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:Rel.updateFunction:VAL"></A>
<DT> <CODE>updateFunction (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>rel</VAR>, <VAR>x</VAR>, <VAR>y</VAR>)</CODE>
<DD>
If <CODE><VAR>rel</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, then <CODE>updateFunction</CODE> returns the function that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE> and is the updating of the function <CODE><VAR>rel</VAR></CODE> to send <CODE><VAR>x</VAR></CODE> to <CODE><VAR>y</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> isn't a function.
<BR>
<BR>

<DT> <A NAME="STR:Rel.mlFunctionToFunction:VAL"></A>
<DT> <CODE>mlFunctionToFunction (<VAR>cmp</VAR>, <VAR>cmp'</VAR>) (<VAR>f</VAR>, <VAR>xs</VAR>)</CODE>
<DD>
If <CODE><VAR>xs</VAR></CODE> is compatible with <CODE><VAR>cmp</VAR></CODE>, then <CODE>mlFunctionToFunction</CODE> returns the function <CODE><VAR>rel</VAR></CODE> that is compatible with <CODE><VAR>cmp</VAR></CODE> and <CODE><VAR>cmp'</VAR></CODE>, whose domain is <CODE><VAR>xs</VAR></CODE>, and where, for all elements <CODE><VAR>x</VAR></CODE> of <CODE><VAR>xs</VAR></CODE>, <CODE>(<VAR>x</VAR>, <VAR>f</VAR> <VAR>x</VAR>)</CODE> is a member of <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>f</VAR></CODE> raises an exception when called on one or more elements of <CODE><VAR>xs</VAR></CODE>.  (Will fail to terminate, if <CODE><VAR>f</VAR></CODE> fails to terminate when called on one or more elements of <CODE><VAR>xs</VAR></CODE>.)
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="sort-set-rel-tab-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.7</I><BR>
<I>Copyright &copy; 2018 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
