<!-- HTML/efa.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The EFA Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>EFA</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="EFA:SIG:SPEC"></A><CODE>EFA</CODE><BR>
<B>structure</B>&nbsp;<A NAME="EFA:STR:SPEC"></A><CODE>EFA</CODE><B> :> </B>EFA<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module defines the abstract type of empty-string finite automata (EFAs).
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<A NAME="STR:EFA.efa:TY:SPEC" HREF="#STR:EFA.efa:TY">efa</A><BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.injToFA:VAL:SPEC" HREF="#STR:EFA.injToFA:VAL">injToFA</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;FA.fa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.valid:VAL:SPEC" HREF="#STR:EFA.valid:VAL">valid</A>&nbsp;<B>:</B>&nbsp;FA.fa&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.projFromFA:VAL:SPEC" HREF="#STR:EFA.projFromFA:VAL">projFromFA</A>&nbsp;<B>:</B>&nbsp;FA.fa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.fromString:VAL:SPEC" HREF="#STR:EFA.fromString:VAL">fromString</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.input:VAL:SPEC" HREF="#STR:EFA.input:VAL">input</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.toPP:VAL:SPEC" HREF="#STR:EFA.toPP:VAL">toPP</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;PP.pp<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.toString:VAL:SPEC" HREF="#STR:EFA.toString:VAL">toString</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;string<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.output:VAL:SPEC" HREF="#STR:EFA.output:VAL">output</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.states:VAL:SPEC" HREF="#STR:EFA.states:VAL">states</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.startState:VAL:SPEC" HREF="#STR:EFA.startState:VAL">startState</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.acceptingStates:VAL:SPEC" HREF="#STR:EFA.acceptingStates:VAL">acceptingStates</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.transitions:VAL:SPEC" HREF="#STR:EFA.transitions:VAL">transitions</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Tran.tran&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.compare:VAL:SPEC" HREF="#STR:EFA.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.equal:VAL:SPEC" HREF="#STR:EFA.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.numStates:VAL:SPEC" HREF="#STR:EFA.numStates:VAL">numStates</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.numTransitions:VAL:SPEC" HREF="#STR:EFA.numTransitions:VAL">numTransitions</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.alphabet:VAL:SPEC" HREF="#STR:EFA.alphabet:VAL">alphabet</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.sub:VAL:SPEC" HREF="#STR:EFA.sub:VAL">sub</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.transitionFun:VAL:SPEC" HREF="#STR:EFA.transitionFun:VAL">transitionFun</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.transitionFunBackwards:VAL:SPEC" HREF="#STR:EFA.transitionFunBackwards:VAL">transitionFunBackwards</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.processStr:VAL:SPEC" HREF="#STR:EFA.processStr:VAL">processStr</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.accepted:VAL:SPEC" HREF="#STR:EFA.accepted:VAL">accepted</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Str.str&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.emptyClose:VAL:SPEC" HREF="#STR:EFA.emptyClose:VAL">emptyClose</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.emptyCloseBackwards:VAL:SPEC" HREF="#STR:EFA.emptyCloseBackwards:VAL">emptyCloseBackwards</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.reachify:VAL:SPEC" HREF="#STR:EFA.reachify:VAL">reachify</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.reachified:VAL:SPEC" HREF="#STR:EFA.reachified:VAL">reachified</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.renameStates:VAL:SPEC" HREF="#STR:EFA.renameStates:VAL">renameStates</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.renameStatesCanonically:VAL:SPEC" HREF="#STR:EFA.renameStatesCanonically:VAL">renameStatesCanonically</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.isomorphism:VAL:SPEC" HREF="#STR:EFA.isomorphism:VAL">isomorphism</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.findIsomorphismOpt:VAL:SPEC" HREF="#STR:EFA.findIsomorphismOpt:VAL">findIsomorphismOpt</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;SymRel.sym_rel&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.findIsomorphism:VAL:SPEC" HREF="#STR:EFA.findIsomorphism:VAL">findIsomorphism</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;SymRel.sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.isomorphic:VAL:SPEC" HREF="#STR:EFA.isomorphic:VAL">isomorphic</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.renameAlphabet:VAL:SPEC" HREF="#STR:EFA.renameAlphabet:VAL">renameAlphabet</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.checkLP:VAL:SPEC" HREF="#STR:EFA.checkLP:VAL">checkLP</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;LP.lp&nbsp;<B>-></B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.validLP:VAL:SPEC" HREF="#STR:EFA.validLP:VAL">validLP</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;LP.lp&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.findLPOpt:VAL:SPEC" HREF="#STR:EFA.findLPOpt:VAL">findLPOpt</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-></B>&nbsp;LP.lp&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.findLP:VAL:SPEC" HREF="#STR:EFA.findLP:VAL">findLP</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-></B>&nbsp;LP.lp<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.findAcceptingLPOpt:VAL:SPEC" HREF="#STR:EFA.findAcceptingLPOpt:VAL">findAcceptingLPOpt</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Str.str&nbsp;<B>-></B>&nbsp;LP.lp&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.findAcceptingLP:VAL:SPEC" HREF="#STR:EFA.findAcceptingLP:VAL">findAcceptingLP</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;Str.str&nbsp;<B>-></B>&nbsp;LP.lp<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.emptyStr:VAL:SPEC" HREF="#STR:EFA.emptyStr:VAL">emptyStr</A>&nbsp;<B>:</B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.emptySet:VAL:SPEC" HREF="#STR:EFA.emptySet:VAL">emptySet</A>&nbsp;<B>:</B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.fromSym:VAL:SPEC" HREF="#STR:EFA.fromSym:VAL">fromSym</A>&nbsp;<B>:</B>&nbsp;Sym.sym&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.simplify:VAL:SPEC" HREF="#STR:EFA.simplify:VAL">simplify</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.simplified:VAL:SPEC" HREF="#STR:EFA.simplified:VAL">simplified</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.union:VAL:SPEC" HREF="#STR:EFA.union:VAL">union</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.concat:VAL:SPEC" HREF="#STR:EFA.concat:VAL">concat</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.closure:VAL:SPEC" HREF="#STR:EFA.closure:VAL">closure</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.genUnion:VAL:SPEC" HREF="#STR:EFA.genUnion:VAL">genUnion</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;list&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.genConcat:VAL:SPEC" HREF="#STR:EFA.genConcat:VAL">genConcat</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;list&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.rev:VAL:SPEC" HREF="#STR:EFA.rev:VAL">rev</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.inter:VAL:SPEC" HREF="#STR:EFA.inter:VAL">inter</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>*</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.genInter:VAL:SPEC" HREF="#STR:EFA.genInter:VAL">genInter</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;list&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.prefix:VAL:SPEC" HREF="#STR:EFA.prefix:VAL">prefix</A>&nbsp;<B>:</B>&nbsp;efa&nbsp;<B>-></B>&nbsp;efa<BR>
<B>val</B>&nbsp;<A NAME="STR:EFA.fromFA:VAL:SPEC" HREF="#STR:EFA.fromFA:VAL">fromFA</A>&nbsp;<B>:</B>&nbsp;FA.fa&nbsp;<B>-></B>&nbsp;efa</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:EFA.efa:TY"></A><CODE><B>type</B>&nbsp;efa</CODE>
<DD>
The abstract type of EFAs, which is a proper subset of the set of FAs.
<BR>
<BR>

<DT> <A NAME="STR:EFA.injToFA:VAL"></A>
<DT> <CODE>injToFA <VAR>efa</VAR></CODE>
<DD>
inject <CODE><VAR>efa</VAR></CODE> to have type <CODE>FA.fa</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:EFA.valid:VAL"></A>
<DT> <CODE>valid <VAR>fa</VAR></CODE>
<DD>
tests whether <CODE><VAR>fa</VAR></CODE> is an EFA.
<BR>
<BR>

<DT> <A NAME="STR:EFA.projFromFA:VAL"></A>
<DT> <CODE>projFromFA <VAR>fa</VAR></CODE>
<DD>
projects <CODE><VAR>fa</VAR></CODE> to have type <CODE>efa</CODE>.  Issues an error message if <CODE><VAR>fa</VAR></CODE> is not an EFA.
<BR>
<BR>

<DT> <A NAME="STR:EFA.fromString:VAL"></A>
<DT> <CODE>fromString <VAR>s</VAR></CODE>
<DD>
inputs an EFA from a string.
<BR>
<BR>

<DT> <A NAME="STR:EFA.input:VAL"></A>
<DT> <CODE>input <VAR>fil</VAR></CODE>
<DD>
inputs an EFA from the file named <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:EFA.toPP:VAL"></A>
<DT> <CODE>toPP <VAR>fa</VAR></CODE>
<DD>
returns a pretty-printing expression for <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.toString:VAL"></A>
<DT> <CODE>toString <VAR>efa</VAR></CODE>
<DD>
pretty-prints <CODE><VAR>efa</VAR></CODE> to a string.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.output:VAL"></A>
<DT> <CODE>output(<VAR>fil</VAR>, <VAR>efa</VAR>)</CODE>
<DD>
pretty-prints <CODE><VAR>efa</VAR></CODE> to the file <CODE><VAR>fil</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.states:VAL"></A>
<DT> <CODE>states <VAR>efa</VAR></CODE>
<DD>
returns the states of <CODE><VAR>efa</VAR></CODE>.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.startState:VAL"></A>
<DT> <CODE>startState <VAR>efa</VAR></CODE>
<DD>
returns the start state of <CODE><VAR>efa</VAR></CODE>.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.acceptingStates:VAL"></A>
<DT> <CODE>acceptingStates <VAR>efa</VAR></CODE>
<DD>
returns the accepting states of <CODE><VAR>efa</VAR></CODE>.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.transitions:VAL"></A>
<DT> <CODE>transitions <VAR>efa</VAR></CODE>
<DD>
returns the transitions of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.compare:VAL"></A>
<DT> <CODE>compare(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
compares <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE> in the total ordering on FAs.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.equal:VAL"></A>
<DT> <CODE>equal(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE> are equal. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.numStates:VAL"></A>
<DT> <CODE>numStates <VAR>efa</VAR></CODE>
<DD>
returns the number of states of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.numTransitions:VAL"></A>
<DT> <CODE>numTransitions <VAR>efa</VAR></CODE>
<DD>
returns the number of transitions of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.alphabet:VAL"></A>
<DT> <CODE>alphabet <VAR>efa</VAR></CODE>
<DD>
returns the alphabet of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.sub:VAL"></A>
<DT> <CODE>sub(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>efa1</VAR></CODE> is a sub-EFA of <CODE><VAR>efa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.transitionFun:VAL"></A>
<DT> <CODE>transitionFun <VAR>efa</VAR> (<VAR>q</VAR>, <VAR>x</VAR>)</CODE>
<DD>
returns the set of all states <CODE><VAR>r</VAR></CODE> such that <CODE>(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>r</VAR>)</CODE> is a transition of <CODE><VAR>efa</VAR></CODE>. Issues an error message if <CODE><VAR>q</VAR></CODE> is not a state of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.transitionFunBackwards:VAL"></A>
<DT> <CODE>transitionFunBackwards <VAR>efa</VAR> (<VAR>r</VAR>, <VAR>x</VAR>)</CODE>
<DD>
returns the set of all states <CODE><VAR>q</VAR></CODE> such that <CODE>(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>r</VAR>)</CODE> is a transition of <CODE><VAR>efa</VAR></CODE>. Issues an error message if <CODE><VAR>r</VAR></CODE> is not a state of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.processStr:VAL"></A>
<DT> <CODE>processStr <VAR>efa</VAR> (<VAR>qs</VAR>, <VAR>x</VAR>)</CODE>
<DD>
processes <CODE><VAR>x</VAR></CODE> from <CODE><VAR>qs</VAR></CODE> in <CODE><VAR>efa</VAR></CODE>.  Issues an error message if <CODE><VAR>qs</VAR></CODE> has an element that's not a state of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.accepted:VAL"></A>
<DT> <CODE>accepted <VAR>efa</VAR> <VAR>x</VAR></CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> is accepted by <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.emptyClose:VAL"></A>
<DT> <CODE>emptyClose <VAR>efa</VAR> <VAR>qs</VAR></CODE>
<DD>
returns the empty-closure of <CODE><VAR>qs</VAR></CODE> for <CODE><VAR>efa</VAR></CODE>.  Issues an error message if <CODE><VAR>qs</VAR></CODE> has an element that's not a state of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.emptyCloseBackwards:VAL"></A>
<DT> <CODE>emptyCloseBackwards <VAR>efa</VAR> <VAR>qs</VAR></CODE>
<DD>
returns the backwards empty-closure of <CODE><VAR>qs</VAR></CODE> for <CODE><VAR>efa</VAR></CODE>.  Issues an error message if <CODE><VAR>qs</VAR></CODE> has an element that's not a state of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.reachify:VAL"></A>
<DT> <CODE>reachify <VAR>efa</VAR></CODE>
<DD>
reachifies <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.reachified:VAL"></A>
<DT> <CODE>reachified <VAR>efa</VAR></CODE>
<DD>
tests whether <CODE><VAR>efa</VAR></CODE> is reachified. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.renameStates:VAL"></A>
<DT> <CODE>renameStates(<VAR>efa</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
renames the states of <CODE><VAR>efa</VAR></CODE> using the bijection <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> is not a bijection from the states of <CODE><VAR>efa</VAR></CODE> to some set. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.renameStatesCanonically:VAL"></A>
<DT> <CODE>renameStatesCanonically <VAR>efa</VAR></CODE>
<DD>
canonically renames the states of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.isomorphism:VAL"></A>
<DT> <CODE>isomorphism(<VAR>efa1</VAR>, <VAR>efa2</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is an isomorphism from <CODE><VAR>efa1</VAR></CODE> to <CODE><VAR>efa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.findIsomorphismOpt:VAL"></A>
<DT> <CODE>findIsomorphismOpt(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
returns <CODE>SOME</CODE> of an isomorphism from <CODE><VAR>efa1</VAR></CODE> to <CODE><VAR>efa2</VAR></CODE>, if <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE> are isomorphic, and <CODE>NONE</CODE>, if <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE> are not isomorphic.
<BR>
<BR>

<DT> <A NAME="STR:EFA.findIsomorphism:VAL"></A>
<DT> <CODE>findIsomorphism(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
tries to find an isomorphism from <CODE><VAR>efa1</VAR></CODE> to <CODE><VAR>efa2</VAR></CODE>.  Issues an error message if such an isomorphism doesn't exist. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.isomorphic:VAL"></A>
<DT> <CODE>isomorphic(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE> are isomorphic. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.renameAlphabet:VAL"></A>
<DT> <CODE>renameAlphabet(<VAR>efa</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
renames the alphabet of <CODE><VAR>efa</VAR></CODE> using the bijection <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> is not a bijection from a superset of the alphabet of <CODE><VAR>efa</VAR></CODE> to some set. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.checkLP:VAL"></A>
<DT> <CODE>checkLP <VAR>efa</VAR> <VAR>lp</VAR></CODE>
<DD>
checks whether <CODE><VAR>lp</VAR></CODE> is valid for <CODE><VAR>efa</VAR></CODE>, silently returning <CODE>()</CODE>, if it is, and explaining why it isn't, if it's not. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.validLP:VAL"></A>
<DT> <CODE>validLP <VAR>efa</VAR> <VAR>lp</VAR></CODE>
<DD>
tests whether <CODE><VAR>lp</VAR></CODE> is valid for <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.findLPOpt:VAL"></A>
<DT> <CODE>findLPOpt <VAR>efa</VAR> (<VAR>qs</VAR>, <VAR>x</VAR>, <VAR>rs</VAR>)</CODE>
<DD>
returns <CODE>SOME</CODE> of a minimal labeled path for <CODE><VAR>efa</VAR></CODE>, taking <CODE><VAR>qs</VAR></CODE> to <CODE><VAR>rs</VAR></CODE> with label <CODE><VAR>x</VAR></CODE>, if such a labeled path exists, and <CODE>NONE</CODE>, if such a labeled path does not exist.
<BR>
<BR>

<DT> <A NAME="STR:EFA.findLP:VAL"></A>
<DT> <CODE>findLP <VAR>efa</VAR> (<VAR>qs</VAR>, <VAR>x</VAR>, <VAR>rs</VAR>)</CODE>
<DD>
tries to find a minimal labeled path for <CODE><VAR>efa</VAR></CODE>, taking <CODE><VAR>qs</VAR></CODE> to <CODE><VAR>rs</VAR></CODE> with label <CODE><VAR>x</VAR></CODE>. Issues an error message if there is an element of <CODE><VAR>qs</VAR></CODE> or <CODE><VAR>rs</VAR></CODE> that isn't a state of <CODE><VAR>efa</VAR></CODE>, or such a labeled path doesn't exist. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.findAcceptingLPOpt:VAL"></A>
<DT> <CODE>findAcceptingLPOpt <VAR>efa</VAR> <VAR>x</VAR></CODE>
<DD>
returns <CODE>SOME</CODE> of a minimal, accepting labeled path for <CODE><VAR>efa</VAR></CODE> and <CODE><VAR>x</VAR></CODE>, if such a labeled path exists, and <CODE>NONE</CODE>, if such a labeled path doesn't exist.
<BR>
<BR>

<DT> <A NAME="STR:EFA.findAcceptingLP:VAL"></A>
<DT> <CODE>findAcceptingLP <VAR>efa</VAR> <VAR>x</VAR></CODE>
<DD>
tries to find a minimal, accepting labeled path for <CODE><VAR>efa</VAR></CODE> and <CODE><VAR>x</VAR></CODE>.  Issues an error message if such a labeled path doesn't exist. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.emptyStr:VAL"></A>
<DT> <CODE>emptyStr</CODE>
<DD>
is the canonical EFA for the empty string. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.emptySet:VAL"></A>
<DT> <CODE>emptySet</CODE>
<DD>
is the canonical EFA for the empty set. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.fromSym:VAL"></A>
<DT> <CODE>fromSym <VAR>a</VAR></CODE>
<DD>
returns the canonical EFA for <CODE><VAR>a</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.simplify:VAL"></A>
<DT> <CODE>simplify <VAR>efa</VAR></CODE>
<DD>
simplifies <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.simplified:VAL"></A>
<DT> <CODE>simplified <VAR>efa</VAR></CODE>
<DD>
tests whether <CODE><VAR>efa</VAR></CODE> is simplified. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.union:VAL"></A>
<DT> <CODE>union(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
returns the union of <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.concat:VAL"></A>
<DT> <CODE>concat(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
returns the concatentation of <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.closure:VAL"></A>
<DT> <CODE>closure <VAR>efa</VAR></CODE>
<DD>
returns the closure of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.genUnion:VAL"></A>
<DT> <CODE>genUnion</CODE>
<DD>
is defined by: 
<PRE>
  fun genUnion nil           = emptySet
    | genUnion [efa]         = efa
    | genUnion (efa :: efas) = union(efa, genUnion efas)
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:EFA.genConcat:VAL"></A>
<DT> <CODE>genConcat</CODE>
<DD>
is defined by: 
<PRE>
  fun genConcat nil           = emptyStr
    | genConcat [efa]         = efa
    | genConcat (efa :: efas) = concat(efa, genConcat efas)
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:EFA.rev:VAL"></A>
<DT> <CODE>rev <VAR>efa</VAR></CODE>
<DD>
returns the reversal of <CODE><VAR>efa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:EFA.inter:VAL"></A>
<DT> <CODE>inter(<VAR>efa1</VAR>, <VAR>efa2</VAR>)</CODE>
<DD>
returns the intersection of <CODE><VAR>efa1</VAR></CODE> and <CODE><VAR>efa2</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:EFA.genInter:VAL"></A>
<DT> <CODE>genInter</CODE>
<DD>
is defined by: 
<PRE>
  fun genInter nil           = (* issues an error message *)
    | genInter [efa]         = efa
    | genInter (efa :: efas) = inter(inter, genInter efas)
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:EFA.prefix:VAL"></A>
<DT> <CODE>prefix <VAR>efa</VAR></CODE>
<DD>
returns the prefix-closure of <CODE><VAR>efa</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:EFA.fromFA:VAL"></A>
<DT> <CODE>fromFA <VAR>fa</VAR></CODE>
<DD>
converts <CODE><VAR>fa</VAR></CODE> to an EFA.
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="reg-fa-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.11</I><BR>
<I>Copyright &copy; 2019 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
