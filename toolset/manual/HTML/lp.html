<!-- HTML/lp.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The LP Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>LP</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="LP:SIG:SPEC"></A><CODE>LP</CODE><BR>
<B>structure</B>&nbsp;<A NAME="LP:STR:SPEC"></A><CODE>LP</CODE><B> :> </B>LP<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module defines the abstract type of labeled paths.
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>datatype</B>&nbsp;<A NAME="STR:LP.concr:TY:SPEC" HREF="#STR:LP.concr:TY">concr</A><BR>
&nbsp;&nbsp;=&nbsp;<A NAME="STR:LP.Sym:TY:SPEC" HREF="#STR:LP.Sym:TY">Sym</A>&nbsp;<B>of</B>&nbsp;Sym.sym<BR>
&nbsp;&nbsp;|&nbsp;<A NAME="STR:LP.Cons:TY:SPEC" HREF="#STR:LP.Cons:TY">Cons</A>&nbsp;<B>of</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;concr<BR>
<B>type</B>&nbsp;<A NAME="STR:LP.lp:TY:SPEC" HREF="#STR:LP.lp:TY">lp</A><BR>
<B>val</B>&nbsp;<A NAME="STR:LP.fromConcr:VAL:SPEC" HREF="#STR:LP.fromConcr:VAL">fromConcr</A>&nbsp;<B>:</B>&nbsp;concr&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.toConcr:VAL:SPEC" HREF="#STR:LP.toConcr:VAL">toConcr</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;concr<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.fromString:VAL:SPEC" HREF="#STR:LP.fromString:VAL">fromString</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.input:VAL:SPEC" HREF="#STR:LP.input:VAL">input</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.toPP:VAL:SPEC" HREF="#STR:LP.toPP:VAL">toPP</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;PP.pp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.toString:VAL:SPEC" HREF="#STR:LP.toString:VAL">toString</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;string<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.output:VAL:SPEC" HREF="#STR:LP.output:VAL">output</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>*</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.compare:VAL:SPEC" HREF="#STR:LP.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.equal:VAL:SPEC" HREF="#STR:LP.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>*</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.sym:VAL:SPEC" HREF="#STR:LP.sym:VAL">sym</A>&nbsp;<B>:</B>&nbsp;Sym.sym&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.cons:VAL:SPEC" HREF="#STR:LP.cons:VAL">cons</A>&nbsp;<B>:</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.startState:VAL:SPEC" HREF="#STR:LP.startState:VAL">startState</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;Sym.sym<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.endState:VAL:SPEC" HREF="#STR:LP.endState:VAL">endState</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;Sym.sym<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.label:VAL:SPEC" HREF="#STR:LP.label:VAL">label</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;Str.str<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.length:VAL:SPEC" HREF="#STR:LP.length:VAL">length</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.join:VAL:SPEC" HREF="#STR:LP.join:VAL">join</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>*</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.splitAt:VAL:SPEC" HREF="#STR:LP.splitAt:VAL">splitAt</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>*</B>&nbsp;int&nbsp;<B>-&gt;</B>&nbsp;lp&nbsp;<B>*</B>&nbsp;lp<BR>
<B>type</B>&nbsp;<A NAME="STR:LP.pumping_division:TY:SPEC" HREF="#STR:LP.pumping_division:TY">pumping_division</A>&nbsp;=&nbsp;lp&nbsp;<B>*</B>&nbsp;lp&nbsp;<B>*</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.checkPumpingDivision:VAL:SPEC" HREF="#STR:LP.checkPumpingDivision:VAL">checkPumpingDivision</A>&nbsp;<B>:</B>&nbsp;pumping_division&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.validPumpingDivision:VAL:SPEC" HREF="#STR:LP.validPumpingDivision:VAL">validPumpingDivision</A>&nbsp;<B>:</B>&nbsp;pumping_division&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.strsOfValidPumpingDivision:VAL:SPEC" HREF="#STR:LP.strsOfValidPumpingDivision:VAL">strsOfValidPumpingDivision</A>&nbsp;<B>:</B>&nbsp;pumping_division&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Str.str<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.pumpValidPumpingDivision:VAL:SPEC" HREF="#STR:LP.pumpValidPumpingDivision:VAL">pumpValidPumpingDivision</A>&nbsp;<B>:</B>&nbsp;pumping_division&nbsp;<B>*</B>&nbsp;int&nbsp;<B>-&gt;</B>&nbsp;lp<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.findValidPumpingDivision:VAL:SPEC" HREF="#STR:LP.findValidPumpingDivision:VAL">findValidPumpingDivision</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;pumping_division<BR>
<B>val</B>&nbsp;<A NAME="STR:LP.findValidPumpingDivisionOpt:VAL:SPEC" HREF="#STR:LP.findValidPumpingDivisionOpt:VAL">findValidPumpingDivisionOpt</A>&nbsp;<B>:</B>&nbsp;lp&nbsp;<B>-&gt;</B>&nbsp;pumping_division&nbsp;option</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:LP.concr:TY"></A><CODE><B>datatype</B>&nbsp;concr<BR>
&nbsp;&nbsp;=&nbsp;Sym&nbsp;<B>of</B>&nbsp;Sym.sym<BR>
&nbsp;&nbsp;|&nbsp;Cons&nbsp;<B>of</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;concr</CODE>
<DD>
The concrete datatype of labeled paths.  If <CODE><VAR>q</VAR></CODE> is a symbol, then <CODE>Sym <VAR>q</VAR></CODE> is the labeled path with no transitions, and whose start and end states are <CODE><VAR>q</VAR></CODE>.  And if <CODE><VAR>q</VAR></CODE> is a symbol, <CODE><VAR>x</VAR></CODE> is a string, and <CODE><VAR>lp</VAR></CODE> is a labeled path, then <CODE>Cons(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>lp</VAR>)</CODE> is the labeled path whose start state is <CODE><VAR>q</VAR></CODE>, whose first transition is from <CODE><VAR>q</VAR></CODE> to the start state of <CODE><VAR>lp</VAR></CODE>, labeled by <CODE><VAR>x</VAR></CODE>, and whose remaining transitions and end state are as in <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.lp:TY"></A><CODE><B>type</B>&nbsp;lp</CODE>
<DD>
The abstract type of labeled paths, consisting of the values of type <CODE>concr</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.fromConcr:VAL"></A>
<DT> <CODE>fromConcr <VAR>concr</VAR></CODE>
<DD>
returns <CODE><VAR>concr</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.toConcr:VAL"></A>
<DT> <CODE>toConcr <VAR>lp</VAR></CODE>
<DD>
returns <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.fromString:VAL"></A>
<DT> <CODE>fromString <VAR>s</VAR></CODE>
<DD>
inputs a labled path from <CODE><VAR>s</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.input:VAL"></A>
<DT> <CODE>input <VAR>fil</VAR></CODE>
<DD>
inputs a labeled path from the file named by <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.toPP:VAL"></A>
<DT> <CODE>toPP <VAR>lp</VAR></CODE>
<DD>
returns a pretty-printing expression for <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.toString:VAL"></A>
<DT> <CODE>toString <VAR>lp</VAR></CODE>
<DD>
pretty-prints <CODE><VAR>lp</VAR></CODE> to a string.
<BR>
<BR>

<DT> <A NAME="STR:LP.output:VAL"></A>
<DT> <CODE>output(<VAR>fil</VAR>, <VAR>lp</VAR>)</CODE>
<DD>
pretty-prints <CODE><VAR>lp</VAR></CODE> to the file named by <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.compare:VAL"></A>
<DT> <CODE>compare</CODE>
<DD>
is defined by: 
<PRE>
  fun compare(Sym a1,            Sym a2)            = Sym.compare(a1, a2)
    | compare(Sym _,             _)                 = LESS
    | compare(_,                 Sym _)             = GREATER
    | compare(Cons(a1, x1, lp1), Cons(a2, x2, lp2)) =
        case Sym.compare(a1, a2) of
             LESS    =&gt; LESS
           | EQUAL   =&gt;
               (case Str.compare(x1, x2) of
                     LESS    =&gt; LESS
                   | EQUAL   =&gt; compare(lp1, lp2)
                   | GREATER =&gt; GREATER)
           | GREATER =&gt; GREATER
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:LP.equal:VAL"></A>
<DT> <CODE>equal(<VAR>lp1</VAR>, <VAR>lp2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>lp1</VAR></CODE> and <CODE><VAR>lp2</VAR></CODE> are equal.
<BR>
<BR>

<DT> <A NAME="STR:LP.sym:VAL"></A>
<DT> <CODE>sym <VAR>q</VAR></CODE>
<DD>
returns <CODE>Sym <VAR>q</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.cons:VAL"></A>
<DT> <CODE>cons(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>lp</VAR>)</CODE>
<DD>
returns <CODE>Cons(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>lp</VAR>)</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.startState:VAL"></A>
<DT> <CODE>startState <VAR>lp</VAR></CODE>
<DD>
returns the start state of <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.endState:VAL"></A>
<DT> <CODE>endState <VAR>lp</VAR></CODE>
<DD>
returns the end state of <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.label:VAL"></A>
<DT> <CODE>label <VAR>lp</VAR></CODE>
<DD>
returns the label of <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.length:VAL"></A>
<DT> <CODE>length <VAR>lp</VAR></CODE>
<DD>
returns the length of <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.join:VAL"></A>
<DT> <CODE>join(<VAR>lp1</VAR>, <VAR>lp2</VAR>)</CODE>
<DD>
returns the join of <CODE><VAR>lp1</VAR></CODE> and <CODE><VAR>lp2</VAR></CODE>. Issues an error message if the end state of <CODE><VAR>lp1</VAR></CODE> is not equal to the start state of <CODE><VAR>lp2</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.splitAt:VAL"></A>
<DT> <CODE>splitAt(<VAR>lp</VAR>, <VAR>n</VAR>)</CODE>
<DD>
returns the pair <CODE>(<VAR>lp1</VAR>, <VAR>lp2</VAR>)</CODE> such that the length of <CODE><VAR>lp1</VAR></CODE> is <CODE><VAR>n</VAR></CODE> and <CODE><VAR>lp</VAR></CODE> is the join of <CODE><VAR>lp1</VAR></CODE> and <CODE><VAR>lp2</VAR></CODE>. Issues an error message if <CODE><VAR>n</VAR></CODE> is negative or is is greater than the length of <CODE><VAR>lp</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:LP.pumping_division:TY"></A><CODE><B>type</B>&nbsp;pumping_division&nbsp;=&nbsp;lp&nbsp;<B>*</B>&nbsp;lp&nbsp;<B>*</B>&nbsp;lp</CODE>
<DD>
The following functions on pumping divisions can be used to experiment with the pumping lemma for regular languages.
<P>
A pumping division <CODE>(<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>)</CODE> is <EM>valid</EM> iff: 
<UL>
<LI>
the end state of <CODE><VAR>lp1</VAR></CODE> is equal to the start state of <CODE><VAR>lp2</VAR></CODE>;
<LI>
the start state and end states of <CODE><VAR>lp2</VAR></CODE> are equal;
<LI>
the end state of <CODE><VAR>lp2</VAR></CODE> is equal to the start state of <CODE><VAR>lp3</VAR></CODE>;
<LI>
the label of <CODE><VAR>lp2</VAR></CODE> is nonempty.
</UL>
<BR>
<BR>

<DT> <A NAME="STR:LP.checkPumpingDivision:VAL"></A>
<DT> <CODE>checkPumpingDivision <VAR>pd</VAR></CODE>
<DD>
checks whether <CODE><VAR>pd</VAR></CODE> is valid, silently returning <CODE>()</CODE>, if it is, and issuing an error message explaining why it's not, if it's not.
<BR>
<BR>

<DT> <A NAME="STR:LP.validPumpingDivision:VAL"></A>
<DT> <CODE>validPumpingDivision <VAR>pd</VAR></CODE>
<DD>
tests whether <CODE><VAR>pd</VAR></CODE> is valid.
<BR>
<BR>

<DT> <A NAME="STR:LP.strsOfValidPumpingDivision:VAL"></A>
<DT> <CODE>strsOfValidPumpingDivision <VAR>pd</VAR></CODE>
<DD>
returns the triple consisting of the labels of the three components of <CODE><VAR>pd</VAR></CODE>, in order.  Issues an error message if <CODE><VAR>pd</VAR></CODE> is not a valid pumping division.
<BR>
<BR>

<DT> <A NAME="STR:LP.pumpValidPumpingDivision:VAL"></A>
<DT> <CODE>pumpValidPumpingDivision(<VAR>pd</VAR>, <VAR>n</VAR>)</CODE>
<DD>
returns the labeled path consisting of the join of <CODE>#1 <VAR>pd</VAR></CODE>, <CODE><VAR>lp</VAR></CODE> and <CODE>#3 <VAR>pd</VAR></CODE>, where <CODE><VAR>lp</VAR></CODE> is the result of joining <CODE>#2 <VAR>pd</VAR></CODE> with itself <CODE><VAR>n</VAR></CODE> times. (Joining a labeled path <CODE><VAR>lp</VAR></CODE> with itself <CODE>0</CODE> times results in <CODE>Sym(startState <VAR>lp</VAR>)</CODE>.  Joining <CODE><VAR>lp</VAR></CODE> with itself <CODE>1</CODE> time results in <CODE><VAR>lp</VAR></CODE>.) Issues an error message if <CODE><VAR>pd</VAR></CODE> isn't valid or <CODE><VAR>n</VAR></CODE> is negative.
<BR>
<BR>

<DT> <A NAME="STR:LP.findValidPumpingDivision:VAL"></A>
<DT> <CODE>findValidPumpingDivision <VAR>lp</VAR></CODE>
<DD>
tries to find a pumping division <CODE>(<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>)</CODE> such that: 
<UL>
<LI>
<CODE>(<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>)</CODE> is valid;
<LI>
<CODE>pumpValidPumpingDivision((<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>), 1)</CODE> is <CODE><VAR>lp</VAR></CODE>; and
<LI>
there is no repetition of states in the result of joining <CODE><VAR>lp1</VAR></CODE> and <CODE>splitAt(<VAR>lp2</VAR>, length <VAR>lp2</VAR> - 1)</CODE>.
</UL>
 Issues an error message if <CODE><VAR>lp</VAR></CODE> lacks a repetition of states, so that such a pumping division doesn't exist.
<BR>
<BR>

<DT> <A NAME="STR:LP.findValidPumpingDivisionOpt:VAL"></A>
<DT> <CODE>findValidPumpingDivisionOpt <VAR>lp</VAR></CODE>
<DD>
If <CODE><VAR>lp</VAR></CODE> has a repetition of states, then <CODE>findValidPumpingDivisionOpt</CODE> returns <CODE>SOME</CODE> of a pumping division <CODE>(<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>)</CODE> such that: 
<UL>
<LI>
<CODE>(<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>)</CODE> is valid;
<LI>
<CODE>pumpValidPumpingDivision((<VAR>lp1</VAR>, <VAR>lp2</VAR>, <VAR>lp3</VAR>), 1)</CODE> is <CODE><VAR>lp</VAR></CODE>; and
<LI>
there is no repetition of states in the result of joining <CODE><VAR>lp1</VAR></CODE> and <CODE>splitAt(<VAR>lp2</VAR>, length <VAR>lp2</VAR> - 1)</CODE>.
</UL>
 Otherwise, <CODE>findValidPumpingDivisionOpt</CODE> returns <CODE>NONE</CODE>
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="reg-fa-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.10</I><BR>
<I>Copyright &copy; 2018 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
