<!-- HTML/nfa.html -->

<!-- COPYRIGHT (c) 2012 Alley Stoughton. -->

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>The NFA Module</TITLE>
<META NAME=generator CONTENT="ML-Doc::html-gen">
</HEAD>
<BODY><A NAME="top"></A>
<H1 align=CENTER>Forlan Manual</H1>
<HR>


<H2><A NAME="section:0"></A>The <CODE>NFA</CODE> Module</H2>
<HR>
<H4>Synopsis</H4>
<BLOCKQUOTE>
<CODE><B>signature</B>&nbsp;<A NAME="NFA:SIG:SPEC"></A><CODE>NFA</CODE><BR>
<B>structure</B>&nbsp;<A NAME="NFA:STR:SPEC"></A><CODE>NFA</CODE><B> :> </B>NFA<BR>
</CODE>
</BLOCKQUOTE>
<P>
This module defines the abstract type of nondeterministic finite automata (NFAs).
<HR>
<H4>Interface</H4>
<BLOCKQUOTE>
<CODE><B>type</B>&nbsp;<A NAME="STR:NFA.nfa:TY:SPEC" HREF="#STR:NFA.nfa:TY">nfa</A><BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.injToFA:VAL:SPEC" HREF="#STR:NFA.injToFA:VAL">injToFA</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;FA.fa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.injToEFA:VAL:SPEC" HREF="#STR:NFA.injToEFA:VAL">injToEFA</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;EFA.efa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.valid:VAL:SPEC" HREF="#STR:NFA.valid:VAL">valid</A>&nbsp;<B>:</B>&nbsp;FA.fa&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.projFromFA:VAL:SPEC" HREF="#STR:NFA.projFromFA:VAL">projFromFA</A>&nbsp;<B>:</B>&nbsp;FA.fa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.projFromEFA:VAL:SPEC" HREF="#STR:NFA.projFromEFA:VAL">projFromEFA</A>&nbsp;<B>:</B>&nbsp;EFA.efa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.fromString:VAL:SPEC" HREF="#STR:NFA.fromString:VAL">fromString</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.input:VAL:SPEC" HREF="#STR:NFA.input:VAL">input</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.toPP:VAL:SPEC" HREF="#STR:NFA.toPP:VAL">toPP</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;PP.pp<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.toString:VAL:SPEC" HREF="#STR:NFA.toString:VAL">toString</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;string<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.output:VAL:SPEC" HREF="#STR:NFA.output:VAL">output</A>&nbsp;<B>:</B>&nbsp;string&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.states:VAL:SPEC" HREF="#STR:NFA.states:VAL">states</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.startState:VAL:SPEC" HREF="#STR:NFA.startState:VAL">startState</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.acceptingStates:VAL:SPEC" HREF="#STR:NFA.acceptingStates:VAL">acceptingStates</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.transitions:VAL:SPEC" HREF="#STR:NFA.transitions:VAL">transitions</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Tran.tran&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.compare:VAL:SPEC" HREF="#STR:NFA.compare:VAL">compare</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;Sort.total_ordering<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.equal:VAL:SPEC" HREF="#STR:NFA.equal:VAL">equal</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.numStates:VAL:SPEC" HREF="#STR:NFA.numStates:VAL">numStates</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.numTransitions:VAL:SPEC" HREF="#STR:NFA.numTransitions:VAL">numTransitions</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;int<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.alphabet:VAL:SPEC" HREF="#STR:NFA.alphabet:VAL">alphabet</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.sub:VAL:SPEC" HREF="#STR:NFA.sub:VAL">sub</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.transitionFun:VAL:SPEC" HREF="#STR:NFA.transitionFun:VAL">transitionFun</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.transitionFunBackwards:VAL:SPEC" HREF="#STR:NFA.transitionFunBackwards:VAL">transitionFunBackwards</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.processStr:VAL:SPEC" HREF="#STR:NFA.processStr:VAL">processStr</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.accepted:VAL:SPEC" HREF="#STR:NFA.accepted:VAL">accepted</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.reachify:VAL:SPEC" HREF="#STR:NFA.reachify:VAL">reachify</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.reachified:VAL:SPEC" HREF="#STR:NFA.reachified:VAL">reachified</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.renameStates:VAL:SPEC" HREF="#STR:NFA.renameStates:VAL">renameStates</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.renameStatesCanonically:VAL:SPEC" HREF="#STR:NFA.renameStatesCanonically:VAL">renameStatesCanonically</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.isomorphism:VAL:SPEC" HREF="#STR:NFA.isomorphism:VAL">isomorphism</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.findIsomorphismOpt:VAL:SPEC" HREF="#STR:NFA.findIsomorphismOpt:VAL">findIsomorphismOpt</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;SymRel.sym_rel&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.findIsomorphism:VAL:SPEC" HREF="#STR:NFA.findIsomorphism:VAL">findIsomorphism</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;SymRel.sym_rel<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.isomorphic:VAL:SPEC" HREF="#STR:NFA.isomorphic:VAL">isomorphic</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.renameAlphabet:VAL:SPEC" HREF="#STR:NFA.renameAlphabet:VAL">renameAlphabet</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;SymRel.sym_rel&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.checkLP:VAL:SPEC" HREF="#STR:NFA.checkLP:VAL">checkLP</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;LP.lp&nbsp;<B>-&gt;</B>&nbsp;unit<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.validLP:VAL:SPEC" HREF="#STR:NFA.validLP:VAL">validLP</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;LP.lp&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.findLPOpt:VAL:SPEC" HREF="#STR:NFA.findLPOpt:VAL">findLPOpt</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;LP.lp&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.findLP:VAL:SPEC" HREF="#STR:NFA.findLP:VAL">findLP</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>*</B>&nbsp;Str.str&nbsp;<B>*</B>&nbsp;Sym.sym&nbsp;Set.set&nbsp;<B>-&gt;</B>&nbsp;LP.lp<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.findAcceptingLPOpt:VAL:SPEC" HREF="#STR:NFA.findAcceptingLPOpt:VAL">findAcceptingLPOpt</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;LP.lp&nbsp;option<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.findAcceptingLP:VAL:SPEC" HREF="#STR:NFA.findAcceptingLP:VAL">findAcceptingLP</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;Str.str&nbsp;<B>-&gt;</B>&nbsp;LP.lp<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.emptyStr:VAL:SPEC" HREF="#STR:NFA.emptyStr:VAL">emptyStr</A>&nbsp;<B>:</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.emptySet:VAL:SPEC" HREF="#STR:NFA.emptySet:VAL">emptySet</A>&nbsp;<B>:</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.fromSym:VAL:SPEC" HREF="#STR:NFA.fromSym:VAL">fromSym</A>&nbsp;<B>:</B>&nbsp;Sym.sym&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.simplify:VAL:SPEC" HREF="#STR:NFA.simplify:VAL">simplify</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.simplified:VAL:SPEC" HREF="#STR:NFA.simplified:VAL">simplified</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;bool<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.inter:VAL:SPEC" HREF="#STR:NFA.inter:VAL">inter</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>*</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.genInter:VAL:SPEC" HREF="#STR:NFA.genInter:VAL">genInter</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;list&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.prefix:VAL:SPEC" HREF="#STR:NFA.prefix:VAL">prefix</A>&nbsp;<B>:</B>&nbsp;nfa&nbsp;<B>-&gt;</B>&nbsp;nfa<BR>
<B>val</B>&nbsp;<A NAME="STR:NFA.fromEFA:VAL:SPEC" HREF="#STR:NFA.fromEFA:VAL">fromEFA</A>&nbsp;<B>:</B>&nbsp;EFA.efa&nbsp;<B>-&gt;</B>&nbsp;nfa</CODE>
</BLOCKQUOTE>
<H4>Description</H4>
<DL>
<DT> <A NAME="STR:NFA.nfa:TY"></A><CODE><B>type</B>&nbsp;nfa</CODE>
<DD>
The abstract type of NFAs, which is a proper subset of the set of EFAs (and thus FAs).
<BR>
<BR>

<DT> <A NAME="STR:NFA.injToFA:VAL"></A>
<DT> <CODE>injToFA <VAR>nfa</VAR></CODE>
<DD>
inject <CODE><VAR>nfa</VAR></CODE> to have type <CODE>FA.fa</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:NFA.injToEFA:VAL"></A>
<DT> <CODE>injToEFA <VAR>nfa</VAR></CODE>
<DD>
inject <CODE><VAR>nfa</VAR></CODE> to have type <CODE>EFA.efa</CODE>.
<BR>
<BR>

<DT> <A NAME="STR:NFA.valid:VAL"></A>
<DT> <CODE>valid <VAR>fa</VAR></CODE>
<DD>
tests whether <CODE><VAR>fa</VAR></CODE> is an NFA.
<BR>
<BR>

<DT> <A NAME="STR:NFA.projFromFA:VAL"></A>
<DT> <CODE>projFromFA <VAR>fa</VAR></CODE>
<DD>
projects <CODE><VAR>fa</VAR></CODE> to have type <CODE>nfa</CODE>.  Issues an error message if <CODE><VAR>fa</VAR></CODE> is not an NFA.
<BR>
<BR>

<DT> <A NAME="STR:NFA.projFromEFA:VAL"></A>
<DT> <CODE>projFromEFA <VAR>efa</VAR></CODE>
<DD>
projects <CODE><VAR>efa</VAR></CODE> to have type <CODE>nfa</CODE>.  Issues an error message if <CODE><VAR>efa</VAR></CODE> is not an NFA.
<BR>
<BR>

<DT> <A NAME="STR:NFA.fromString:VAL"></A>
<DT> <CODE>fromString <VAR>s</VAR></CODE>
<DD>
inputs an NFA from a string.
<BR>
<BR>

<DT> <A NAME="STR:NFA.input:VAL"></A>
<DT> <CODE>input <VAR>fil</VAR></CODE>
<DD>
inputs an NFA from the file named <CODE><VAR>fil</VAR></CODE>.
<BR>
<BR>

<DT> <A NAME="STR:NFA.toPP:VAL"></A>
<DT> <CODE>toPP <VAR>fa</VAR></CODE>
<DD>
returns a pretty-printing expression for <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.toString:VAL"></A>
<DT> <CODE>toString <VAR>nfa</VAR></CODE>
<DD>
pretty-prints <CODE><VAR>nfa</VAR></CODE> to a string.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.output:VAL"></A>
<DT> <CODE>output(<VAR>fil</VAR>, <VAR>nfa</VAR>)</CODE>
<DD>
pretty-prints <CODE><VAR>nfa</VAR></CODE> to the file <CODE><VAR>fil</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.states:VAL"></A>
<DT> <CODE>states <VAR>nfa</VAR></CODE>
<DD>
returns the states of <CODE><VAR>nfa</VAR></CODE>.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.startState:VAL"></A>
<DT> <CODE>startState <VAR>nfa</VAR></CODE>
<DD>
returns the start state of <CODE><VAR>nfa</VAR></CODE>.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.acceptingStates:VAL"></A>
<DT> <CODE>acceptingStates <VAR>nfa</VAR></CODE>
<DD>
returns the accepting states of <CODE><VAR>nfa</VAR></CODE>.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.transitions:VAL"></A>
<DT> <CODE>transitions <VAR>nfa</VAR></CODE>
<DD>
returns the transitions of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.compare:VAL"></A>
<DT> <CODE>compare(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
compares <CODE><VAR>nfa1</VAR></CODE> and <CODE><VAR>nfa2</VAR></CODE> in the total ordering on FAs.  (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.equal:VAL"></A>
<DT> <CODE>equal(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>nfa1</VAR></CODE> and <CODE><VAR>nfa2</VAR></CODE> are equal. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.numStates:VAL"></A>
<DT> <CODE>numStates <VAR>nfa</VAR></CODE>
<DD>
returns the number of states of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.numTransitions:VAL"></A>
<DT> <CODE>numTransitions <VAR>nfa</VAR></CODE>
<DD>
returns the number of transitions of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.alphabet:VAL"></A>
<DT> <CODE>alphabet <VAR>nfa</VAR></CODE>
<DD>
returns the alphabet of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.sub:VAL"></A>
<DT> <CODE>sub(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>nfa1</VAR></CODE> is a sub-NFA of <CODE><VAR>nfa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.transitionFun:VAL"></A>
<DT> <CODE>transitionFun <VAR>nfa</VAR> (<VAR>q</VAR>, <VAR>x</VAR>)</CODE>
<DD>
returns the set of all states <CODE><VAR>r</VAR></CODE> such that <CODE>(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>r</VAR>)</CODE> is a transition of <CODE><VAR>nfa</VAR></CODE>. Issues an error message if <CODE><VAR>q</VAR></CODE> is not a state of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.transitionFunBackwards:VAL"></A>
<DT> <CODE>transitionFunBackwards <VAR>nfa</VAR> (<VAR>r</VAR>, <VAR>x</VAR>)</CODE>
<DD>
returns the set of all states <CODE><VAR>q</VAR></CODE> such that <CODE>(<VAR>q</VAR>, <VAR>x</VAR>, <VAR>r</VAR>)</CODE> is a transition of <CODE><VAR>nfa</VAR></CODE>. Issues an error message if <CODE><VAR>r</VAR></CODE> is not a state of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.processStr:VAL"></A>
<DT> <CODE>processStr <VAR>nfa</VAR> (<VAR>qs</VAR>, <VAR>x</VAR>)</CODE>
<DD>
processes <CODE><VAR>x</VAR></CODE> from <CODE><VAR>qs</VAR></CODE> in <CODE><VAR>nfa</VAR></CODE>.  Issues an error message if <CODE><VAR>qs</VAR></CODE> has an element that's not a state of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.accepted:VAL"></A>
<DT> <CODE>accepted <VAR>nfa</VAR> <VAR>x</VAR></CODE>
<DD>
tests whether <CODE><VAR>x</VAR></CODE> is accepted by <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.reachify:VAL"></A>
<DT> <CODE>reachify <VAR>nfa</VAR></CODE>
<DD>
reachifies <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.reachified:VAL"></A>
<DT> <CODE>reachified <VAR>nfa</VAR></CODE>
<DD>
tests whether <CODE><VAR>nfa</VAR></CODE> is reachified. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.renameStates:VAL"></A>
<DT> <CODE>renameStates(<VAR>nfa</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
renames the states of <CODE><VAR>nfa</VAR></CODE> using the bijection <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> is not a bijection from the states of <CODE><VAR>nfa</VAR></CODE> to some set. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.renameStatesCanonically:VAL"></A>
<DT> <CODE>renameStatesCanonically <VAR>nfa</VAR></CODE>
<DD>
canonically renames the states of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.isomorphism:VAL"></A>
<DT> <CODE>isomorphism(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>rel</VAR></CODE> is an isomorphism from <CODE><VAR>nfa1</VAR></CODE> to <CODE><VAR>nfa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.findIsomorphismOpt:VAL"></A>
<DT> <CODE>findIsomorphismOpt(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
returns <CODE>SOME</CODE> of an isomorphism from <CODE><VAR>nfa1</VAR></CODE> to <CODE><VAR>nfa2</VAR></CODE>, if <CODE><VAR>nfa1</VAR></CODE> and <CODE><VAR>nfa2</VAR></CODE> are isomorphic, and <CODE>NONE</CODE>, if <CODE><VAR>nfa1</VAR></CODE> and <CODE><VAR>nfa2</VAR></CODE> are not isomorphic.
<BR>
<BR>

<DT> <A NAME="STR:NFA.findIsomorphism:VAL"></A>
<DT> <CODE>findIsomorphism(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
tries to find an isomorphism from <CODE><VAR>nfa1</VAR></CODE> to <CODE><VAR>nfa2</VAR></CODE>.  Issues an error message if such an isomorphism doesn't exist. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.isomorphic:VAL"></A>
<DT> <CODE>isomorphic(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
tests whether <CODE><VAR>nfa1</VAR></CODE> and <CODE><VAR>nfa2</VAR></CODE> are isomorphic. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.renameAlphabet:VAL"></A>
<DT> <CODE>renameAlphabet(<VAR>nfa</VAR>, <VAR>rel</VAR>)</CODE>
<DD>
renames the alphabet of <CODE><VAR>nfa</VAR></CODE> using the bijection <CODE><VAR>rel</VAR></CODE>.  Issues an error message if <CODE><VAR>rel</VAR></CODE> is not a bijection from a superset of the alphabet of <CODE><VAR>nfa</VAR></CODE> to some set. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.checkLP:VAL"></A>
<DT> <CODE>checkLP <VAR>nfa</VAR> <VAR>lp</VAR></CODE>
<DD>
checks whether <CODE><VAR>lp</VAR></CODE> is valid for <CODE><VAR>nfa</VAR></CODE>, silently returning <CODE>()</CODE>, if it is, and explaining why it isn't, if it's not. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.validLP:VAL"></A>
<DT> <CODE>validLP <VAR>nfa</VAR> <VAR>lp</VAR></CODE>
<DD>
tests whether <CODE><VAR>lp</VAR></CODE> is valid for <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.findLPOpt:VAL"></A>
<DT> <CODE>findLPOpt <VAR>nfa</VAR> (<VAR>qs</VAR>, <VAR>x</VAR>, <VAR>rs</VAR>)</CODE>
<DD>
returns <CODE>SOME</CODE> of a minimal labeled path for <CODE><VAR>nfa</VAR></CODE>, taking <CODE><VAR>qs</VAR></CODE> to <CODE><VAR>rs</VAR></CODE> with label <CODE><VAR>x</VAR></CODE>, if such a labeled path exists, and <CODE>NONE</CODE>, if such a labeled path does not exist.
<BR>
<BR>

<DT> <A NAME="STR:NFA.findLP:VAL"></A>
<DT> <CODE>findLP <VAR>nfa</VAR> (<VAR>qs</VAR>, <VAR>x</VAR>, <VAR>rs</VAR>)</CODE>
<DD>
tries to find a minimal labeled path for <CODE><VAR>nfa</VAR></CODE>, taking <CODE><VAR>qs</VAR></CODE> to <CODE><VAR>rs</VAR></CODE> with label <CODE><VAR>x</VAR></CODE>. Issues an error message if there is an element of <CODE><VAR>qs</VAR></CODE> or <CODE><VAR>rs</VAR></CODE> that isn't a state of <CODE><VAR>nfa</VAR></CODE>, or such a labeled path doesn't exist. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.findAcceptingLPOpt:VAL"></A>
<DT> <CODE>findAcceptingLPOpt <VAR>nfa</VAR> <VAR>x</VAR></CODE>
<DD>
returns <CODE>SOME</CODE> of a minimal, accepting labeled path for <CODE><VAR>nfa</VAR></CODE> and <CODE><VAR>x</VAR></CODE>, if such a labeled path exists, and <CODE>NONE</CODE>, if such a labeled path doesn't exist.
<BR>
<BR>

<DT> <A NAME="STR:NFA.findAcceptingLP:VAL"></A>
<DT> <CODE>findAcceptingLP <VAR>nfa</VAR> <VAR>x</VAR></CODE>
<DD>
tries to find a minimal, accepting labeled path for <CODE><VAR>nfa</VAR></CODE> and <CODE><VAR>x</VAR></CODE>.  Issues an error message if such a labeled path doesn't exist. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.emptyStr:VAL"></A>
<DT> <CODE>emptyStr</CODE>
<DD>
is the canonical NFA for the empty string. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.emptySet:VAL"></A>
<DT> <CODE>emptySet</CODE>
<DD>
is the canonical NFA for the empty set. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.fromSym:VAL"></A>
<DT> <CODE>fromSym <VAR>a</VAR></CODE>
<DD>
returns the canonical NFA for <CODE><VAR>a</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.simplify:VAL"></A>
<DT> <CODE>simplify <VAR>nfa</VAR></CODE>
<DD>
simplifies <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.simplified:VAL"></A>
<DT> <CODE>simplified <VAR>nfa</VAR></CODE>
<DD>
tests whether <CODE><VAR>nfa</VAR></CODE> is simplified. (Inherited from <CODE><CODE><A HREF="fa.html#FA:STR:SPEC">FA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.inter:VAL"></A>
<DT> <CODE>inter(<VAR>nfa1</VAR>, <VAR>nfa2</VAR>)</CODE>
<DD>
returns the intersection of <CODE><VAR>nfa1</VAR></CODE> and <CODE><VAR>nfa2</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="efa.html#EFA:STR:SPEC">EFA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.genInter:VAL"></A>
<DT> <CODE>genInter</CODE>
<DD>
is defined by: 
<PRE>
  fun genInter nil           = (* issues an error message *)
    | genInter [nfa]         = nfa
    | genInter (nfa :: nfas) = inter(inter, genInter nfas)
</PRE>
<BR>
<BR>

<DT> <A NAME="STR:NFA.prefix:VAL"></A>
<DT> <CODE>prefix <VAR>nfa</VAR></CODE>
<DD>
returns the prefix-closure of <CODE><VAR>nfa</VAR></CODE>. (Inherited from <CODE><CODE><A HREF="efa.html#EFA:STR:SPEC">EFA</A></CODE></CODE>.)
<BR>
<BR>

<DT> <A NAME="STR:NFA.fromEFA:VAL"></A>
<DT> <CODE>fromEFA <VAR>efa</VAR></CODE>
<DD>
converts <CODE><VAR>efa</VAR></CODE> to an NFA.
<BR>
<BR>

</DL>


<HR>
<CENTER>
<B>[ <A HREF="#top">Top</A>
   | <A HREF="reg-fa-subsect.html">Parent</A>
   | <A HREF="index.html">Root</A>
   | <A HREF="toc.html">Contents</A>
   | <A HREF="index-all.html">Index</A>
   ]</B>
</CENTER>
<P>
<I>Forlan Version 4.7</I><BR>
<I>Copyright &copy; 2018 Alley Stoughton</I><BR>

<HR>
</BODY></HTML>
